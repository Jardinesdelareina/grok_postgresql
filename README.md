# СУБД PostgreSQL

Данный репозиторий является базой знаний об открытом программном обеспечении PostgreSQL - системе управления базами данных. Вся информация взята из общедоступных источников и несет исключительно образовательную цель.

<div>
    <img src="https://github.com/devicons/devicon/blob/master/icons/postgresql/postgresql-original-wordmark.svg" width="80" height="80"/>&nbsp;
</div>


### Реляционная модель данных

<em>Реляционная модель данных</em> - это математическая модель, которая описывает способ организации и хранения данных в базе данных. Она основана на понятии "таблицы" или "реляции", которая состоит из строк и столбцов.

В реляционной модели каждая таблица имеет набор атрибутов (столбцов), которые определяют тип данных, содержащихся в каждой ячейке столбца. Каждая строка таблицы представляет собой конкретную запись или кортеж данных.

Главная идея реляционной модели заключается в том, что связи между таблицами (реляциями) осуществляются через общие атрибуты, так называемые "внешние ключи". Внешний ключ в таблице ссылается на первичный ключ другой таблицы, что позволяет связывать данные между разными таблицами.

Преимущества реляционной модели данных:
1. Простота структуры и понятность модели,
2. Гибкость и возможность создания сложных запросов для извлечения данных,
3. Независимость от физической реализации данных,
4. Высокая надежность и целостность данных,
5. Поддержка множества операций, таких как сортировка, поиск, фильтрация и соединение данных.


### Типы данных PostgreSQL

Типы данных [описаны в документации](https://postgrespro.ru/docs/postgresql/14/datatype). 

Некоторые типы данных PostgreSQL:

1. Числовые:
   - `INTEGER` (целочисленный тип)
   - `BIGINT` (большие целые числа)
   - `DECIMAL` или `NUMERIC` (число с фиксированной точностью)
   - `REAL` или `FLOAT4` (число с плавающей запятой с одинарной точностью)
   - `DOUBLE PRECISION` или `FLOAT8` (число с плавающей запятой с двойной точностью)

2. Символьные:
   - `CHAR(n)` или `CHARACTER(n)` (строка фиксированной длины)
   - `VARCHAR(n)` или `CHARACTER VARYING(n)` (строка переменной длины)
   - `TEXT` (строка переменной длины без ограничений)

3. Дата и время:
   - `DATE` (дата)
   - `TIME` (время без часового пояса)
   - `TIMESTAMP` (дата и время без часового пояса)
   - `TIMESTAMPTZ` (дата и время с часовым поясом)

4. Логический:
   - `BOOLEAN` (логическое значение: `TRUE` или `FALSE`)

5. Бинарные:
   - `BYTEA` (переменная длина для бинарных данных)

6. Массивы:
   - `INTEGER[]` (массив целых чисел)
   - `VARCHAR(255)[]` (массив строк переменной длины)


### Транзакции и транзакционность

<b>Транзакция</b> в базе данных представляет собой последовательность операций базы данных, которые выполняются как единое целое. Транзакция обладает следующими свойствами, известными как ACID-свойства:

1. <em>Атомарность (Atomicity)</em>: (<b>Всё или ничего</b>) Транзакция либо выполняется полностью, либо не выполняется вообще. Если одна из операций внутри транзакции не может быть выполнена, то вся транзакция откатывается, и все изменения, сделанные до этого, отменяются.

2. <em>Согласованность (Consistency)</em>: (<b>Ограничения целостности и пользовательские ограничения</b>)  Транзакция должна приводить базу данных из одного согласованного состояния в другое согласованное состояние. Это означает, что после завершения транзакции должны быть выполнены все правила целостности БД.

3. <em>Изолированность (Isolation)</em>: (<b>Влияние параллельных процессов</b>) Каждая транзакция должна выполняться изолированно от других транзакций. Изменения, внесенные одной транзакцией, должны быть видимы только после успешного завершения этой транзакции.

4. <em>Долговечность (Durability)</em>: (<b>Сохранность данных даже после сбоя</b>)  После успешного завершения, изменения, сделанные в транзакции, должны быть сохранены и доступны даже в случае сбоя системы или отключения питания.

<b>Транзакционность</b> в базах данных означает, что операции, выполняемые в рамках транзакции, являются неделимыми и отражают только либо полное выполнение, либо отмену всех изменений. Это обеспечивает надежность и целостность данных.

```sql
-- Начало транзакции
BEGIN;

-- Выполнение операций внутри транзакции
UPDATE users
SET balance = balance - 100
WHERE user_id = 1;

UPDATE products
SET quantity = quantity - 1
WHERE product_id = 100;

-- Проверка результатов операций
SELECT * FROM users WHERE user_id = 1;
SELECT * FROM products WHERE product_id = 100;

-- Если все операции выполнены успешно, фиксируем транзакцию
COMMIT;

-- Если произошла ошибка или нужно отменить изменения, откатываем транзакцию
ROLLBACK;
```


### Изоляция и многоверсионность

Уровни изоляции в PostgreSQL обеспечивают контроль над тем, как одна транзакция взаимодействует с данными, когда другие транзакции также работают с теми же данными. Каждый уровень предоставляет разный уровень изоляции и тем самым контролирует то, как изменения видны другим транзакциям. К выбору уровня изоляции следует подходить внимательно, в зависимости от требований к целостности данных и производительности приложения. Реализация уровней изоляции в PostgreSQL строже, чем в стандарте SQL.

Основные уровни изоляции и аномалии, которые предотвращаются на разных уровнях:

1. **Read Uncommitted (Чтение незафиксированных данных)**:

   - **Принцип**: Транзакция на уровне Read Uncommitted может видеть изменения, сделанные другими транзакциями, до их фиксации.

   - **Аномалии**: Может привести к чтению неподтвержденных данных и неконсистентным результатам. 

   <em>Не поддерживается PostgreSQL, работает как <b>Read Committed</b>.</em>


2. **Read Committed (Чтение зафиксированных данных)**:

   - **Принцип**: Транзакция видит только данные, фиксированные другими транзакциями - не видит изменения до фиксации.

   - **Аномалии**: `Dirty Read` - так называемое Грязное чтение, когда читаемые данные могут быть изменены и сделать результаты недействительными. Иными словами, когда одна транзакция может читать измененные, но не зафиксированные строки другой транзакции. И если произойдет ROLLBACK другой транзакции, то первая транзакция прочитает данные, которых никогда не существовало.

   <em>Работает в PostgreSQL по-умолчанию.</em>


3. **Repeatable Read (Повторяемое чтение)**:

   - **Принцип**: Гарантирует, что при повторном выполнении один и тот же запрос получит те же данные. Повторное чтение измененной строки вернет первоначальное значение, если оно было изменено и зафиксировано другой транзакцией. От уровня Read Committed этот уровень изоляции отличается и тем, что на нем транзакция может быть оборвана, чтобы не допустить аномалию (такую транзакцию надо повторять).

   - **Аномалии**: `Non-Repeatable Read` (неповторяющееся чтение) - после того, как первая транзакция прочитала строку, а вторая транзакция ее изменила или удалила и зафиксировала изменения, при повторном чтении первой строки это будет замечено. `Phantom Read`(фантомное чтение) - если прочитанный первой транзакцией набор строк претерпел изменения от второй транзакции, то повтор первой транзакции вернет обновленный набор строк.


4. **Serializable (Сериализуемость)**:

   - **Принцип**: Предотвращает любые аномалии. Обеспечивает максимальный уровень изоляции, предотвращая конфликты между параллельными транзакциями и гарантируя их выполнение как будто бы последовательно. Команды, выполняемые в конкурентно работающих транзакциях, приводят к такому же результату, какой получился бы в случае последовательного — одна транзакция завершилась, следующая началась. Это самый высокий уровень изоляции с наивысшей степенью защиты от аномалий, но может привести к блокировкам и ухудшению производительности, транзакции могут обрываться чаще, чем это действительно необходимо.

   - **Аномалии**: Аномалии конкурентного доступа - это ситуация, когда две или более транзакции пытаются получить доступ к общим данным одновременно, что может привести к конфликту или ошибке.

   <em>Не работает на репликах.</em>


Проверить текущий уровень изоляции:
```sql
SHOW transaction_isolation;
```

Установить уровень изоляции:
```sql
BEGIN;

SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

COMMIT;
```

или

```sql
BEGIN ISOLATION LEVEL READ COMMITTED;

COMMIT;
```

<b>Мультиверсионность (multiversion concurrency control)</b> - это техника, позволяющая обеспечить параллельный доступ к данным для множества пользователей без блокировки или конфликтов. Она базируется на механизме снимков данных, который фиксирует состояние данных на определенный момент времени и позволяет транзакциям видеть данные, как если бы они были изменены после начала транзакции. Каждая транзакция в PostgreSQL видит свою "виртуальную" копию базы данных на момент старта, что позволяет избежать конфликтов записи и обеспечить консистентность данных.

<b>Снимок данных</b> - это состояние базы данных на определенный момент времени, которое является версией данных и остается постоянным в течение всей транзакции. Когда транзакция начинается, PostgreSQL создает снимок данных для этой транзакции, чтобы транзакция видела данные, как они выглядели на момент старта транзакции. Это позволяет транзакциям работать с данными в изолированном режиме, не видя изменений других транзакций до их фиксации.

Преимущества мультиверсионности и снимков данных в PostgreSQL:
1. Повышение производительности: блокировки минимизированы, что позволяет параллельно выполнять множество операций чтения и записи.
2. Изоляция транзакций: каждая транзакция видит свою версию данных, что предотвращает чтение грязных данных.
3. Поддержка скрытия конфликтов: транзакции проходят ряд уровней изоляции, определяющих видимость данных другим транзакциям.


### Буферный кэш

Буферный кэш (buffer cache) - это механизм в PostgreSQL, который используется для временного хранения данных из дискового хранилища в оперативной памяти. Кэш помогает ускорить доступ к данным, так как операции чтения и записи данных в оперативной памяти гораздо быстрее, чем на диске.

Когда PostgreSQL загружает данные таблицы или индекса с диска, он кэширует их в буферный кэш. При обращении к данным, PostgreSQL в первую очередь проверяет их наличие в кэше. Если данные уже присутствуют в кэше, то запрос может быть выполнен непосредственно из оперативной памяти, ускоряя его выполнение. В случае отсутствия данных в кэше, PostgreSQL считывает их с диска.

Использование буферного кэша помогает уменьшить количество обращений к диску, что повышает производительность системы и снижает задержки в выполнении запросов. Однако необходимо учитывать ограниченный объем оперативной памяти, который может быть выделен под буферный кэш, и настраивать его размер оптимально для конкретной системы.


##### Влияние буферного кэша на выполнение запросов

Создадим базу данных
```sql
CREATE DATABASE test_data_db;
```

Подключимся к ней
`\c test_data_db`

Создадим таблицу
```sql
CREATE TABLE t (n INTEGER);
```

Наполним ее данными (100 тысяч записей)
```sql
INSERT INTO t SELECT id FROM generate_series(1, 100000) AS id;
```

Выполним очистку
```sql
VACUUM ANALYZE t;
```

Выйдем из psql
`\q`

Выполним рестарт сервера PostgreSQL чтобы сбросить содержимое буферного кэша
`sudo service postgresql restart`

Подключимся к базе данных занова
`psql test_data_db`

Выполним запрос
```sql
EXPLAIN (analyze, buffers, costs off, timing off)
SELECT * FROM t;
```

И если ввести этот запрос еще раз, то показатели Planning Time и Execution Time будут гораздо меньше, так как во время выполнения второго запроса данные брались уже из буферного кэша.


### Журнал предзаписи WAL (write-ahead log)

Журнал записей транзакций - это механизм, который используется для обеспечения надежности и восстановления данных в случае сбоев. Когда происходит изменение данных в БД, PostgreSQL сначала записывает это изменение в журнал WAL, прежде чем фактически изменить страницу данных. Иными словами, сначала происходит запись о транзакции в журнал WAL, затем происходит сама транзакция. Это обеспечивает атомарность и целостность транзакций. 

В журнал WAL не попадают записи только о временных и нежурналируемых (unlogged) таблицах. Операции над данными в нежурналируемых таблицах производятся гораздо быстрее, но не попадают в WAL. Такие таблицы создаются в первую очередь для таких данных, потеря которых не критична.

WAL содержит последовательность записей, представляющих изменения данных, произведенные транзакциями. Этот журнал можно использовать для восстановления данных после сбоя. В случае сбоя PostgreSQL может восстановить данные, применив изменения из WAL к последнему снимку базы данных.

WAL также используется для обеспечения согласованности данных в репликации, позволяя повторить все изменения данных на других серверах в той же последовательности, что и на основном сервере.


### TOAST

TOAST (The Oversized-Attribute Storage Technique) - это метод в PostgreSQL для хранения больших значений полей, которые не могут быть сохранены в обычном страничном формате базы данных. Например, это может быть текст или бинарные данные, размер которых превышает предельное значение (обычно 2 кБ).

TOAST работает путем переноса исходных данных в отдельное хранилище и замены их в таблице специальными ссылками, что позволяет компактно хранить и эффективно обрабатывать большие объекты.

TOAST позволяет эффективно работать с большими данными, не увеличивая размер таблицы и позволяет PostgreSQL автоматически управлять процессом хранения и извлечения этих данных.

Все TOAST-таблицы хранятся в схеме `pg_toast`.


### Репликация

Репликация - это процесс синхронизации нескольких копий кластера баз данных на разных серверах. 

Задачи репликации:
* Отказоустойчивость - при выходе из строя одного из серверов система должна сохранить доступность.

* Масштабируемость - распределение нагрузки между серверами. 

