# Репликация кластера баз данных

Репликация - это процесс создания и поддержания копии базы данных (мастер-базы) на другом сервере (реплике). Репликация позволяет распределить нагрузку на несколько серверов, обеспечить отказоустойчивость и увеличить производительность системы. Репликация может быть асинхронной или синхронной, в зависимости от того, как быстро изменения на мастер-базе должны быть переданы на реплику.

### Цели репликации

* Отказоустойчивость: один физический сервер - это возможная точка отказа. Если сервер выходит из строя, система становится недоступной.

* Производительность. Один сервер может не справляться с нагрузкой. Зачастую наращиванию мощности сервера предпочтительна возможность масштабирования - распределения нагрузки на несколько серверов. Таким образом, речь идет о том, чтобы иметь несколько серверов, работающих над одними и теми же базами данных. Под репликацией понимается процесс синхронизации этих серверов.

Взаимодействие нескольких серверов можно организовать по-разному. Два основных подхода, доступных в PostgreSQL - физическая и логическая репликация.

* <b>Физическая репликация</b> уместна в случаях, когда требуется максимальная производительность и минимальная задержка между мастером и репликами. Механизм работы физической репликации - передача на реплику изменений в виде записей журнала предзаписи Она является более эффективной в случаях, когда кластер большой и содержит большое количество данных. Физическая репликация копирует бинарные данные (требует двоичной совместимости между серверами) напрямую с мастера на реплики, что позволяет минимизировать задержку и использовать высокоскоростные соединения.

Физическая репликация всегда однонаправлена: в ней может существовать только один мастер (и произвольное число реплик). При данном подходе реплика постоянно поддерживается в почти актуальном состоянии и в случае является сервером, готовым подхватить работу в случае аварии на мастере.
В отличие от резервной копии, репликация не позволяет восстановиться на произвольный момент в прошлом.

<em>Пример с физической репликацией: Онлайн-магазин, где важна быстрая загрузка страницы и обработка заказов. Физическая репликация поможет обеспечить высокую производительность и минимальную задержку при обновлении данных на репликах.</em>

*  <b>Логическая репликация</b> уместна, если требуется более гибкий контроль над данными и возможность выборочной репликации. Логическая репликация позволяет выбирать, какие данные должны быть реплицированы, и может быть полезна в ситуациях, когда нужно исключить определенные таблицы или столбцы из репликации.

<em>Пример с логической репликацией: Корпоративное приложение с большим количеством таблиц, где не все данные должны быть доступны на всех уровнях. Логическая репликация позволит выбирать, какие данные реплицировать на разные серверы и обеспечить более гибкую конфигурацию.</em>


### Физическая репликация

Физическая репликация - это процесс создания копии базы данных (мастер-базы данных) на другом сервере (реплика). Эта копия является точной физической копией оригинальной базы данных и включает в себя все данные, таблицы, индексы и другие объекты.

Физическая репликация может быть использована для повышения отказоустойчивости системы, увеличения производительности путем балансировки нагрузки между мастером и репликой, а также для обеспечения географической репликации данных для обеспечения их доступности и безопасности.

Механизм репликации состоит в том, что один сервер передает журнальные записи на другой сервер, и тот их проигрывает — как при восстановлении после сбоя. Поскольку журнал общий для всего кластера, то и реплицировать можно только весь кластер целиком.

<em>Поскольку на реплику попадает только та информация, которая содержится в журнале, в журнал должны записываться все необходимые данные. Объем информации, попадающий в журнал, регулируется параметром `wal_level`.</em>

Чтобы организовать репликацию между двумя серверами, нужно создать реплику из физической резервной копии основного сервера. При обычном восстановлении из такой резервной копии получается новый независимый сервер. А если включить репликацию, ведомый сервер начинает работать в режиме постоянного восстановления: он все время применяет новые журнальные записи, приходящие с основного сервера. Таким образом, реплика постоянно поддерживается в почти актуальном состоянии.


### Процедура репликации

Проверка, что включен параметр `replica` и сколько может быть включено процессов одновременно:
```sql
SELECT name, setting 
FROM pg_settings 
WHERE name IN ('wal_level', 'max_val_senders');
```

Проверка, включено ли разрешение на подключение по протоколу репликации:
```sql
SELECT type, user_name, address, auth_method FROM pg_hba_file_rules
WHERE database = ARRAY['replication'];
```

`sudo rm -rf /home/fueros/tmp/backup`

Инициализировать новый кластер:
`initdb --username=postgres --pwprompt -E UTF8 /var/lib/postgresql/14/replica`      --pwprompt указывает initdb запросить пароль, который будет назначен суперпользователю базы данных. Это не важно, если не планируется использовать аутентификацию по паролю. В ином случае этот режим аутентификации оказывается неприменимым, пока пароль не задан.

Создание резервной копии кластера (-R сформирует необходимые для репликации конфигурационные параметры). Ключ -R создаст указание серверу перейти в режим постоянного восстановления, а также поместит в файл postgresql.auto.conf настройки для подключения к основному серверу.
`pg_basebackup --pgdata=/home/fueros/tmp/backup -R --checkpoint=fast`

Остановить его, если сервер работает:
`sudo pg_ctlcluster 14 replica stop`

Очистка каталога кластера:
`sudo rm -rf /var/lib/postgresql/14/replica`

Перенос физической копии в каталог кластера:
`sudo mv /home/student/tmp/backup /var/lib/postgresql/14/replica`

Назначение пользователя postgres владельцем файлов каталога кластера:
`sudo chown -R postgres:postgres /var/lib/postgresql/14/replica`

Проверка содержимого каталога нового кластера:
`sudo ls -l /var/lib/postgresql/14/replica`

Проверка, что необходимый кластер, куда будет создана реплика, остановлен (down):
`sudo pg_lsclusters`

Запуск нового кластера:
`sudo pg_ctlcluster 14 replica start`

Просмотр процессов масера/реплики:
`sudo head -n 1 '/var/lib/postgresql/16/main/postmaster.pid'`

`sudo head -n 1 '/var/lib/postgresql/16/replica/postmaster.pid'

Чтобы сравнить процессы, нужно вставить номер pid:
`ps -o pid,command --ppid <номер процесса>`

Посмотреть состояние реприкации:
```sql
SELECT * FROM pg_stat_replication \gx
```

Подключение к реплике:
`psql -p 5433 -d replica_db`


При использовании репликации кластера 
<b>ДОПУСКАЕТСЯ</b>:
* Запросы на чтение данных (SELECT, COPY TO, курсоры)
* Установка параметров сервера (SET, RESET)
* Управление транзакциями (BEGIN, COMMIT, ROLLBACK...)
* Создание резервной копии (pg_basebackup)

<b>НЕ ДОПУСКАЕТСЯ</b>:
* Любые изменения (INSERT, UPDATE, DELETE, TRUNCATE, nextval...)
* Блокировки, предполагающие изменение (SELECT FOR UPDATE...)
* Команды DDL (CREATE, DROP...), в т. ч. создание временных таблиц
* Команды сопровождения (VACUUM, ANALYZE, REINDEX...)
* Управление доступом (GRANT, REVOKE...)
* Не срабатывают триггеры и рекомендательные блокировки


### Восстановление

При восстановлении базовая резервная копия, включающая необходимые файлы WAL, разворачивается на другом сервере. 

<b>Процедура восстановления выполняется следующим образом:</b>
На другом (или на том же) сервере разворачивается базовая резервная копия и создается файл `recovery.signal`. Сервер запускается и начинает читать сегменты WAL из архива, используя `restore_command`, и применять их.

Резервный сервер применяет все доступные записи WAL, читая сегменты из каталога pg_wal, тем самым доводя состояние баз данных до актуального. Максимально возможная потеря - незаполненный сегмент WAL, не попавший в архив, если его по каким-то причинам невозможно скопировать. По-умолчанию применяются все доступные журнальные записи, а указание целевой точки восстановления позволяет остановить их применение в желаемый момент.

После этого резервный сервер переходит в обычный режим работы: принимает запросы, записывает сегменты WAL в архив и так далее, выступая в качестве нового полноценного основного сервера.Если развернутый сервер предполагается использовать вместо основного, то его имеет смысл располагать на таком же или, по крайней мере, сравнимом по характеристикам аппаратуры сервере, чтобы избежать снижения производительности.


* <b>pg_receivewal</b> 
Утилита предназначена для записи сегментов в архив по протоколу потоковой репликации. Обычно она запускается на отдельном "архивном" сервере и подключается к мастеру с параметрами, указанными в ключах. Утилита может (и должна) использовать слот репликации, чтобы гарантированно не потерять записи. Утилита формирует файлы аналогично тому, как это делает сервер, и записывает их в указанный каталог. Еще не заполненные сегменты записываются с префиксом `.partial`. При переходе на новый сервер утилиту требуется остановить и запустить заново с соответствующими параметрами.

Утилита `pg_receivewal` подключается к серверу по протоколу потоковой репликации. Подключение обрабатывается отдельным процессом `wal sender` (это необходимо учесть при установке параметра max_wal_senders). Утилита записывает данные, не дожидаясь получения всего сегмента.


#### Потоковый архив

Создание кластера для архивации WAL:
`mkdir /var/lib/postgresql/archive`

Создание слота:
`pg_receivewal --create-slot --slot=archive`

Запуск утилиты в фоновом режиме (запустить в отдельном окне или вставить в конце командной строки символ &):
`pg_receivewal -D /var/lib/postgresql/archive --slot=archive`


#### Базовая резервная копия 

Автономная резервная копия кластера main:
`pg_basebackup --wal-method=none --pgdata=/home/fueros/basebackup`


#### Переход на реплику

В случае выхода основного сервера из строя или при штатной необходимости работ реплике дается команда прекратить восстановление и стать самостоятельным сервером, а бывший мастер отключается. 

В случае сбоя переход осуществляется вручную, так как PostgreSQL не имеет встроенного кластерного программного обеспечения, которое должно следить за состоянием серверов и инициировать переход:
`sudo pg_ctlcluster 14 replica promote`

После восстановления бывшего основного сервера или окончания других работ на нем он подключается в качестве реплики к новому работающему мастеру.

Проверка, является ли кластер репликой:
```sql
SELECT pg_is_in_recovery();
```

#### Настройка синхронного режима репликации:

```sql
ALTER SYSTEM SET synchronous_commit = on;
```

Просмотр имени кластера реплики:
```sql
SHOW cluster_name;
```

Указание мастеру с какой именно репликой нужно синхронизироваться:
```sql
ALTER SYSTEM SET synchronous_standby_names = '"14/replica"';
```

```sql
SELECT pg_reload_conf();
```

```sql
SELECT sync_state FROM pg_stat_replication;
```


### Логическая репликация

Логическая репликация - это метод репликации данных, при котором копирование данных из одной базы данных в другую осуществляется на уровне логических изменений данных (т.е. INSERT, UPDATE, DELETE). Это означает, что не просто копируются изменения на уровне блоков данных, как при физической репликации, а передаются только сами операции над данными.

При логической репликации у сервера нет выделенной роли мастера или реплики, что позволяет организовать в том числе и двунаправленную репликацию.

Этот метод репликации позволяет более гибко управлять данными на целевом сервере, так как можно применять различные фильтры и трансформации данных перед их записью. Кроме того, логическая репликация может быть более эффективной в случае работы с большими объемами данных, так как не требуется пересылать полные копии блоков данных, а только изменения.

При физической репликации только один сервер (мастер) выполняет изменения и генерирует журнальные записи. Остальные серверы (реплики) только читают журнальные записи мастера и применяют их.При логической репликации все серверы работают в обычном режиме, могут изменять данные и генерировать собственные журнальные записи. Один сервер может публиковать свои изменения, а другие — подписываться на них. При этом один и тот же сервер может как публиковать изменения, так и подписываться на другие. Это позволяет организовать произвольные потоки данных между серверами. Для логической репликации не нужна двоичная совместимость, реплика должна лишь понимать протокол репликации.


Включение логической репликации
`ALTER SYSTEM SET wal_level = logical;`

Создание публикации с привязкой на реплицируемую таблицу
```sql
CREATE PUBLICATION test_publication FOR TABLE test_table;
```

Создание подписки на таблицу 
```sql
CREATE SUBSCRIPTION test_subscription
CONNECTION 'host=localhost port=5432 user=postgres password=postgres dbname=dbtest'
PUBLICATION test_publication;
```

При создании подписки все данные из таблицы test были переданы на сервер-подписчик. Если это не требуется, то к команду `CREATE SUBSCRIPTION` добавляется строка 
```sql
WITH (copy_data = false)
```

Сервер-подписчик тоже может изменять данные в таблице (но эти изменения не будут реплицированы на публикующий сервер).

Если репликация больше не нужна, надо аккуратно удалить подписку — иначе на публикующем сервере останется открытым репликационный слот.

Не реплицируются 
* команды DDL
<em>все изменения схемы данных надо переносить вручную</em>
* значения последовательностей 
<em>если сервер-подписчик добавляет строки в таблицу с суррогатным уникальным ключом, для которой настроена репликация, возможны конфликты. Конфликтов можно избежать, выделяя двум серверам разные диапазоны значений последовательностей, или используя вместо них универсальные уникальные идентификаторы (UUID)</em>
* большие объекты (lo)
* изменения материализованных представлений, сторонних таблиц, секционированных таблиц

Могут вызвать проблемы 
* массовые изменения данных
* изменения, сделанные долгими транзакциями 

Не поддерживаются 
* автоматическое разрешение конфликтов
* двунаправленная репликация одной и той же таблицы