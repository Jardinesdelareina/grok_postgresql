# Администрирование СУБД PostgreSQL


<div>
    <img src="https://github.com/devicons/devicon/blob/master/icons/linux/linux-original.svg" width="40" height="40"/>&nbsp;
    <img src="https://github.com/devicons/devicon/blob/master/icons/postgresql/postgresql-original.svg" width="40" height="40"/>&nbsp;
</div>


### Установка и использование PostgreSQL в Linux

<b>PostgreSQL</b> — программа, которая относится к классу <em>систем управления базами данных</em>. Когда эта программа выполняется, она становится <em>сервером PostgreSQL</em> или <em>экземпляром сервера</em>. Данные, которыми управляет PostgreSQL, хранятся в базах данных. Один экземпляр PostgreSQL одновременно работает с несколькими базами данных. Этот набор баз данных называется <em>кластером баз данных</em>.

* <b>Кластер баз данных</b> - это данные в файлах; 
* <b>Cервер или экземпляр сервера</b> - программа, управляющая кластером баз данных.

[Источник пакетной установки PostgreSQL](https://www.postgresql.org/download/)

<em>Здесь и далее рассматривается пакет PostgreSQL 14.11 для Ubuntu.</em>

Проверить версию сервера:
```sql
SHOW server_version;
```


Для инициализации кластера в Ubuntu создана обертка `pg_createcluster` над утилитой `initdb`. Эта утилита автоматически запускается при установке пакета и создает кластер баз данных с именем "main". Стоит обратить внимание, что инициализация кластера проходит с отключенным подсчетом контрольных сумм в страницах данных.Исполняемые файлы, файлы конфигурации и журнал сервера размещены в соответствии с правилами, принятыми в Ubuntu. Кроме того, настраивается автоматический запуск и останов сервера PostgreSQL при запуске и останове операционной системы.

Для удаления кластера используется утилита `pg_dropcluster`. Утилиты `pg_createcluster` и `pg_dropcluster` специфичны для Ubuntu. В других системах нужно явно инициализировать кластер с помощью `initdb` и задействовать подходящие средства операционной системы.

К основным операциям управления сервером относятся запуск и останов сервера, получение текущего статуса сервера, обновление конфигурации и некоторые другие. Для выполнения этих действий предназначена утилита `pg_ctl`, идущая в составе PostgreSQL. Но в пакетном дистрибутиве для `Ubuntu` доступ к утилите `pg_ctl` осуществляется не напрямую, а через специальную обертку `pg_ctlcluster`. В других системах утилита pg_ctl может использоваться непосредственно.

`sudo pg_ctlcluster 14 main status`     получить текущий статус сервера

`sudo pg_ctlcluster 14 main start`      запустить сервер

`sudo pg_ctlcluster 14 main stop`       остановить сервер

`sudo pg_ctlcluster 14 main restart`    переапустить сервер


##### Расчет контрольных сумм

Контроль расчетных сумм в PostgreSQL необходим для обеспечения правильности данных, а также для обнаружения любых возможных ошибок или несоответствий в базе данных. Это позволяет избежать потенциальных проблем, связанных с неверными результатами вычислений или сбоями в программном обеспечении. Такой контроль также помогает обнаруживать несанкционированные изменения данных и предотвращать возможные атаки на систему.

Перед проверкой нужно отключить сервер PostgreSQL.

`sudo /usr/lib/postgresql/14/bin/pg_checksums --check -D /var/lib/postgresql/14/main`   узнать, включен ли расчет контрольных сумм

`sudo /usr/lib/postgresql/14/bin/pg_checksums --enable -D /var/lib/postgresql/14/main`      включение расчета контрольных сумм

После включения подсчета контрольных сумм сервер нужно запустить.

Проверить при работающем сервере, включены ли контрольные суммы, можно с помощью параметра data_checksums (только для чтения).


### Основные команды PostgreSQL в терминале Linux

`sudo apt-get --purge remove postgresql\*`  удаление PostgreSQL и всех его компонентов

`sudo apt install postgresql`   установка PostgreSQL

`sudo ls -l /usr/lib/postgresql/14/bin`     каталог установки PostgreSQL

`sudo service postgresql status`    проверка, запущен ли сервис

`sudo service postgresql start`     запуск сервера если он не запущен

`sudo service postgresql restart`   перезапуск сервера postgresql

`sudo service postgresql stop`  остановка сервера postgresql

`sudo service postgresql stop -m immediate --skip systemctl-redirect`   остановка сервера postgresql без выполнения контрольной точки

`sudo pg_isready`       проверка, готов ли сервер postgresql принимать подключение от клиентов

`sudo -u postgres psql`     подключение к серверу, активация оболочки <b>psql</b>

`psql -h localhost -U user_name -d db_name`     подключение по локальной сети к базе данных под определенным пользователем

`psql -h localhost -U user_name -d db_name -c "SELECT * FROM table" > /path/to/file/output.txt`     запись результата запроса в файл

`psql < filename` или `psql -f filename`    выполнение файла

`sudo tail -n 10 /var/log/postgresql/postgresql-14-main.log`    вывод 10 последних записей из журнала сообщений сервера

`\q`    выход из <b>psql</b>


### Установка pgAdmin4

1. Установка из репозитория <b>pgAdmin4 APT</b>:

`curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add`

`sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'`

2. Запуск установки <b>pgAdmin4</b>:

`sudo apt install pgadmin4`

3. Запуск скрипта, устанавливающего веб-компоненты. Скрипт находится по адресу `/usr/pgadmin4/bin/setup-web.sh`.

4. В процессе установки будет перезапущена служба Apache2. После завершения работы скрипта необходимо добавить разрешение для Apache2 на доступ через брэндмауэр:

`sudo ufw allow 'Apache'`

5. Запуск брэндмауэра:

`sudo ufw enable`

6. Убедиться, что Apache2 включена в список разрешенных в брэндмауэре:

`sudo ufw status`

7. Для доступа к веб-версии pgAdmin4 ввести в браузере:

`http://<ip-адрес:порт>/pgadmin4`


### Основные команды PSQL

`\! clear`  очистить терминал

`\l`    список баз данных

`\c <db_name>`  подключение к базе данных

`\x`    смена формата вывода результатов запросов (вертикально/горизонтально)

`\dt`   список таблиц базы данных

`\dt <schema_name>.*`   список таблиц определенной схемы

`\du`   список пользователей

`\dn`   список схем базы данных

`\di`   список индексов базы данных

`\dL`   список установленных языков программирования

`\df`   список функций и процедур базы данных

`\dft`  список триггеров базы данных

`\dx`   список расширений базы данных

`\dT`   список составных типов базы данных

`\db`   список табличных пространств

`\dRp+`     список публикаций для логической репликации

`\dew`      список оберток внешних данных

`\des+`     список внешних серверов

`\det`      список внешних таблиц

`\dp <username>.<table>`    список привелегий для таблицы у пользователя

`\i <path_to_file_sql>`    открытие файла (используется для запуска скриптов .sql)

`\gx`   расширенный режим отображения, только для одного запроса (ставится вместо точки с запятой)

`\timing on`  включение счетчика времени выполнения запросов


##### Запись результатов запроса в файл

`\o output.txt`     создание файла

`SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5;`

`\! cat output.txt`


### Конфиурирование сервера PostgreSQL

[Сервис автоматического конфигурирования PostgreSQL (open source)](https://www.pgconfig.org/)


Вывод всех незакоментированных параметров конфигурации из файла `postgresql.conf`:
```sql
SELECT sourceline, name, setting, applied
FROM pg_file_settings
WHERE sourcefile LIKE '/etc/postgresql/14/main/postgresql.conf';
```

Вывод действующих значений параметров из представления `pg_settings`:
```sql
SELECT name, setting, unit,
  boot_val, reset_val,
  source, sourcefile, sourceline,
  pending_restart, context
FROM pg_settings
WHERE name = '<параметр>'\gx
```

Ключевые колонки представления `pg_settings`:
* <b>name</b>, <b>setting</b>, <b>unit</b> — название и значение параметра;
* <b>boot_val</b> — значение по-умолчанию;
* <b>reset_val</b> — значение, которое восстановит команда RESET;
* <b>source</b> — источник текущего значения параметра;
* <b>pending_restart</b> — значение изменено в файле конфигурации, но для применения требуется перезапуск сервера.

Столбец `context` определяет действия, необходимые для применения параметра. Среди возможных значений:
* <em>internal</em> — изменить нельзя, значение задано при установке;
* <em>postmaster</em> — требуется перезапуск сервера;
* <em>sighup</em> — требуется перечитать файлы конфигурации;
* <em>superuser</em> — суперпользователь может изменить для своего сеанса;
* <em>user</em> — любой пользователь может изменить для своего сеанса.


Перезагрузить файл конфигурации postgresql.conf без остановки сервера базы данных:
```sql
SELECT pg_reload_conf();
```


#### postgresql.auto.conf

Файл конфигурации, управляемый командами SQL. Этот файл не следует изменять вручную. Для его редактирования предназначена команда `ALTER SYSTEM`. По сути, эта команда представляет собой SQL-интерфейс для управления параметрами конфигурации.

Для применения изменений, сделанных командой `ALTER SYSTEM`, сервер должен перечитать конфигурационные файлы, как и в случае с изменением файла postgresql.conf. Содержимое обоих файлов (postgresql.conf и postgresql.auto.conf) можно увидеть через представление `pg_file_settings`. А актуальные значения параметров — в представлении `pg_settings`.

```sql
ALTER SYSTEM SET port TO 5433;
```
или
```sql
SELECT set_config('port', 5433, false);
```

Третий параметр функции `set_config` говорит о том, нужно ли устанавливать значение только для текущей транзакции (true) или до конца работы сеанса (false). Это важно при работе приложения через пул соединений, когда в одном сеансе могут выполняться транзакции разных пользователей.


```sql
SHOW port;
```
или
```sql
SELECT current_setting('port');
```

`ALTER SYSTEM RESET <параметр>`     удаляет строку

`ALTER SYSTEM RESET ALL`    удаляет все строки из postgresql.auto.conf


Процесс изменения параметра `work_mem`:
```sql
ALTER SYSTEM SET work_mem TO '128MB';

SELECT pg_reload_conf();
```

Установка параметров внутри транзакции:
```sql
BEGIN;
SET LOCAL work_mem TO '64MB'; 
SHOW work_mem;

 work_mem 
----------
 64MB
(1 row)

COMMIT;

SHOW work_mem;

 work_mem 
----------
 8MB
(1 row)
```

<em>После завершения транзакции значения восстанавливаются. </em>


### Мониторинг

PostgreSQL работает под управлением операционной системы и в известной степени зависит от ее настроек.

Отображение серверных процессов, связанных с postgres (ввод в терминале ОС):
`ps auxww | grep ^postgres`

Каждый обслуживающий процесс собирает необходимую статистику в рамках каждой выполняемой транзакции. Затем эта статистика передается процессу-коллектору. Коллектор собирает и агрегирует статистику со всех обслуживающих процессов. Раз в полсекунды (время настраивается при компиляции) коллектор сбрасывает статистику во временные файлы в каталог `PGDATA/pg_stat_tmp`. Поэтому перенесение этого каталога в файловую систему в памяти может положительно сказаться на производительности. 

Когда обслуживающий процесс запрашивает информацию о статистике (через представления или функции), в его память читается последняя доступная версия статистики — это называется снимком статистики. Если не попросить явно, снимок не будет перечитываться до конца транзакции, чтобы обеспечить согласованность.

При останове сервера коллектор сбрасывает статистику в постоянные файлы в каталог PGDATA/pg_stat. Таким образом, статистика сохраняется при перезапуске сервера. Обнуление счетчиков происходит по команде администратора, а также при восстановлении сервера после сбоя.


[Функции для системного администрирования](https://postgrespro.ru/docs/postgresql/13/functions-admin#FUNCTIONS-ADMIN-DBSIZE)


Просмотр глобальной статистики по всей базе данных:
```sql
SELECT *
FROM pg_stat_database
WHERE datname = 'admin_monitoring' \gx
```

Просмотр информации об обслуживающих процессах (pg_stat_activity):
```sql
SELECT pid, query, state, wait_event, wait_event_type, pg_blocking_pids(pid)
FROM pg_stat_activity
WHERE backend_type = 'client backend' \gx
```

<em>Состояние `idle in transaction` означает, что сеанс начал транзакцию, но в настоящее время ничего не делает, а транзакция осталась незавершенной. Это может стать проблемой, если ситуация возникает систематически (например, из-за некорректной реализации приложения или из-за ошибок в драйвере), поскольку открытый сеанс удерживает снимок данных и таким образом препятствует очистке.</em>


#### Завершение блокирующего сеанса вручную

Сначала нужно узнать номер заблокированного процесса при помощи функции `pg_blocking_pids`:
```sql
SELECT pid AS blocked_pid
FROM pg_stat_activity
WHERE backend_type = 'client backend'
AND cardinality(pg_blocking_pids(pid)) > 0;
```

Прерывание сеанса вызовом `pg_terminate_backend` (pid 16783 указан в качестве примера):
```sql
SELECT pg_terminate_backend(b.pid)
FROM unnest(pg_blocking_pids(16783)) AS b(pid);
```


### Роли и привилегии

Роль - пользователь СУБД. Роль не связана с пользователем ОС, она определяется на уровне кластера.

`CREATE ROLE <роль> [WITH] <атрибут> [атрибут ...]`

<em>LOGIN</em>   возможность подключения

<em>SUPERUSER</em>   суперпользователь

<em>CREATEDB</em>    возможность создавать базы данных

<em>CREATEROLE</em>  возможность создавать роли

<em>REPLICATION</em>     использование протокола репликации

и др.

Создание базы данных
```sql
CREATE DATABASE access_roles;`
```

Подключение к базе данных
`\c access_roles`

Создаем роль для пользователя alice (появляется возможность подключаться и создавать новые роли)
```sql
CREATE ROLE alice LOGIN CREATEROLE;
```

Подключение к базе данных под именем alice

\с - alice

или

`psql -h localhost -U alice acces_roles`

Создание новой роли от alice
```sql
CREATE ROLE bob LOGIN;
```

##### Предопределенные роли

`pg_read_all_settings`  чтение всех параметров сервера

`pg_read_all_stats`     доступ к статистике

`pg_stat_scan_tables`   мониторинг и блокировки таблиц

`pg_read_all_data`      чтение данных из всех таблиц

`pg_write_all_data`     изменение данных во всех таблицах

`pg_read_server_files`      чтение файлов на сервере

`pg_write_server_files`     запись в файлы на сервере

`pg_execute_server_programs`    выполнение программ на сервере


Когда роль создает в базе данных какие-либо объекты, она становится их владельцем. На самом деле владельцами считаются также и роли, включенные в создавшую объект роль.

Передача объектов alice bob`у
`REASSIGN OWNED BY alice TO bob;`


Расположение файла pg_hba.conf:
```sql
SHOW hba_file;
```

Табличное представление файла `pg_hba.conf`:
```sql
SELECT type, database, user_name, address, auth_method
FROM pg_hba_file_rules();
```


##### Примеры использования управления привилегиями

`CREATE ROLE new_user WITH LOGIN PASSWORD 'new_password' VALID UNTIL '2022-12-31';`      создание пользователя и пароля и установление срока учетной записи

`GRANT ALL PRIVILEGES ON DATABASE your_database TO your_username;`      предоставление привилегий новому пользователю

`GRANT CREATE, USAGE ON SCHEMA alice TO bob WITH GRANT OPTION`    предоставление привилегий пользователю bob на создание и использование схем с правом передачи

`REVOKE ALL ON  table FROM bob CASCADE;`    отзыв всех привелегий на таблицу table у bob'а и других ролей в иерархии

`ALTER ROLE your_username NOLOGIN;`     лишение пользователя возможности подключения в базе данных

`GRANT alice TO postgres;`   включение alice в роль postgres

`REVOKE alice TO postgres;`  исключение alice из роли postgres

`ALTER FUNCTION function() SECURITY DEFINER;`   объявление функции как работающей с правами создавшей ее роли


##### Access privileges

* a - INSERT
* r - SELECT
* w - UPDATE
* d - DELETE
* D - TRUNCATE
* x - REFERENCE
* t - TRIGGER


### Политики защиты строк (row-level security policies)

Политики защиты строк (row-level security, RLS) позволяют управлять доступом к таблице на уровне отдельных строк. Политика определяет возможность выборки или изменения строк таблицы с помощью двух предикатов (логических выражений), которые вычисляются для каждой строки запроса. Результаты говорят о том, может ли пользователь видеть или менять строку.

Чтобы политики защиты строк начали работать, нужно явно включить этот механизм для каждой таблицы.

Политики не применяются для суперпользователя и для ролей с атрибутом `BYPASSRLS`.

На одной таблице можно определить несколько политик. В этом случае будут учитываться все предикаты. По-умолчанию создаются разрешительные (PERMISSIVE) политики. Чтобы строка была доступна, достаточно, чтобы хотя бы один из предикатов этих политик был истинен. Но если на таблице включена защита строк, и при этом не определено ни одной разрешительной политики, не будет доступна ни одна строка. Дополнительно можно создать и ограничительные (RESTRICTED) политики. Если они заданы, то все их предикаты должны быть истинны.

Некоторые из операторов управления RLS:
`USING` используется для определения условия, при котором политика защиты строки будет применяться.
`WITH CHECK` определяет условие, которое должно быть выполнено при вставке новой строки или обновлении существующей строки. 
`TO` определяет, кому будет применяться данная политика защиты строки.

<b><em>Применение политики защиты строк на примере таблицы, где для разных ролей доступна видимость разной категории строк:</em></b>

```sql
-- Создание таблицы
CREATE TABLE new_table 
(
  category INTEGER,
  text_column TEXT
);


-- Выдача привелегий пользователям
GRANT SELECT ON new_table TO alice, bob;


-- RLS для alice
CREATE POLICY select_category_1_policy
ON new_table
FOR SELECT
USING (category = 1)
WITH CHECK (category = 1) 
TO alice;

-- RLS для bob
CREATE POLICY select_category_2_policy
ON new_table
FOR SELECT
USING (category = 2)
WITH CHECK (category = 2) 
TO bob;


--Включение защиты на уровне строк для таблицы
ALTER TABLE new_table ENABLE ROW LEVEL SECURITY;
```


### Подключение и аутентификация

<b>Идендификация</b> - определение имени пользователя базы данных
<b>Аутентификация</b> - действительно ли пользователь тот, за кого себя выдает (пароль)
<b>Авторизация</b> - имеет ли данный пользователь право подключаться к серверу (функционал привилегий)

Настройки аутентификации хранятся в конфигурационном файле, который называется `pg_hba.conf`. Он состоит из строк, каждая из которых считается отдельной записью. Пустые строки и комментарии (все после символа #) игнорируются. Строка состоит из полей, разделенных пробелами или табуляциями.

Конфигурационный файл обрабатывается сверху вниз. Для каждой строки определяется, подходит ли она к запрашиваемому клиентом подключению (по соответствию типа подключения, имени БД, имени пользователя и IP-адресу). Если подходит, то выполняется аутентификация указанным в строке методом. Если результат успешен, то подключение разрешается, иначе — запрещается (другие строки при этом уже не рассматриваются). Если ни одна из строк не подошла, то доступ запрещается. Таким образом, записи в файле должны идти сверху вниз от частногок общему.

Узнать используемый в СУБД на данный момент метод шифрования паролей:
```sql
SHOW password_encryption;
```

Сохранить исходный файл перед изменением:
`sudo cp -n /etc/postgresql/13/main/pg_hba.conf ~/pg_hba.conf.orig`

Редактировать файл pg_hba.conf, добавить следующую строку:
`local all postgres trust`

Чтобы применить изменения, нужно перечитать конфигурационный файл:
```sql
SELECT pg_reload_conf();
```

Восстановление исходныx настроек:
`sudo cp ~/pg_hba.conf.orig /etc/postgresql/13/main/pg_hba.conf`

Рестарт сервера:
`sudo pg_ctlcluster 14 main restart`


<b>pg_ident.conf</b>

Правила сопоставления имен определяются в отдельном файле `pg_ident.conf`; его расположение определяется параметром `ident_file`. Файл имеет такую же структуру, как и pg_hba.conf. Записи состоят из трех полей: название соответствия, внешнее имя (имя пользователя ОС), внутреннее имя (роль PostgreSQL).


### Очистка дискового пространства

Задачи, требующие периодического выполнения:

1. <b>Очистка страниц от исторических данных, которые образуются из-за многоверсионности:</b>
Механизм многоверсионности позволяет эффективно реализовать изоляцию на основе снимков, но в результате в табличных страницах  накапливаются старые версии строк, а в страницах индексов — ссылки на эти версии. 

<em>Если своевременно не вычищать исторические данные, таблицы и индексы будут неконтролируемо разрастаться и поиск в них актуальных версий строк будет замедляться.</em>


2. <b>Очистка карты видимости:</b>
В карте видимости отмечены страницы, которые содержат только актуальные версии строк, видимые во всех снимках данных. Иными словами, это страницы, которые давно не изменялись и успели полностью очиститься от неактуальных версий.

Карта видимости применяется:
* Для оптимизации очистки. В отмеченные страницы очистке не надо заглядывать — в них не может быть мертвых версий.
* Для ускорения доступа только по индексу.

<em>Если не обновлять карту видимости, индексный доступ будет работать менее эффективно.</em>


3. <b>Обновление карты свободного пространства:</b>
В карте свободного пространства отмечено наличие пустого места внутри страниц. Карта используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. 

<em>Если периодически не обновлять карту свободного пространства, то с течением времени может произойти фрагментация данных на диске. Это может привести к снижению производительности базы данных, так как СУБД не сможет эффективно управлять свободным пространством и выполнять операции вставки, обновления и удаления данных.</em>


4. <b>Обновление статистики:</b>
Для работы оптимизатора запросов необходима статистическая информация о данных, такая как количество строкв таблицах и распределение данных в столбцах.

<em>Если не обновлять статистику, она перестанет соответствовать реальным данным и оптимизатор станет строить плохие планы выполнения. Из-за этого запросы могут начать выполняться на порядки медленнее, чем могли бы.</em>


5. <b>Заморозка:</b>
Достаточно старые версии строк должны помечаться как "замороженные". Такой признак говорит о том, что версия строки появилась так давно, что номер создавшей ее транзакции больше не имеет значения и его можно использовать повторно.

<em>Если не выполнять заморозку своевременно, сервер не сможет выделить очередной номер транзакции. Это аварийная ситуация: сервер остановится, все незавершенные транзакции оборвутся. После этого администратор должен будет вручную стартовать сервер и выполнить заморозку.</em>


<b>Выполнение всех описанных выше периодических задач обслуживания берет на себя фоновый процесс автоочистки (autovacuum).</b> 

Очистки требуют объекты, в которых накопилось значительное количество ненужных ("мертвых") версий строк. Очищаются также объекты, в которые с момента прошлой очистки было вставлено значительное количество новых строк. Это важно для таблиц, в которые данные только вставляются: их тоже необходимо очищать, чтобы обновить карту видимости и заморозить старые версии.

В случае необходимости можно настроить параметры очистки на уровне отдельных таблиц с помощью параметров хранения: 
```sql
CREATE TABLE ... WITH (параметр=значение);
```

В системе постоянно присутствует процесс `autovacuum launcher`, который планирует работу очистки и запускает необходимое число рабочих процессов `autovacuum worker`, работающих параллельно. Очистка работает постранично, не приводя к блокировкам других транзакций, хотя и создает нагрузку на подсистему ввода-вывода.

Автоматическая очистка перестанет работать при отключении любого из двух параметров `autovacuum` или `track_counts`. Может ошибочно показаться, что отключение способно увеличить производительность системы за счет исключения "лишних" операций ввода-вывода. На самом деле отказ от очистки влечет за собой последствия: неконтролируемое разрастание файлов, замедление запросов и риск аварийной остановки сервера. В конечном итоге это приведет к полному параличу системы.


* <b>VACUUM</b> [таблица]: Эта команда выполняет процесс автоматического освобождения пространства в таблицах, которое было выделено для удаленных, обновленных или вставленных строк. Она также обновляет статистику таблицы, которая используется оптимизатором запросов для выбора наиболее эффективных планов выполнения запросов.

<em>`VACUUM` как одиночный параметр запускает процесс очистки всей базы данных.</em>

* <b>VACUUM VERBOSE</b>: Параметр VERBOSE указывает на то, что при выполнении операции VACUUM будет выводиться более подробная информация о процессе. Это может включать в себя данные о количестве освобожденного пространства, времени выполнения операции, а также другие дополнительные сведения. Указание параметра VERBOSE делает вывод информации более информативным и обычно используется для отслеживания прогресса операции и оценки ее эффективности.

* <b>VACUUM FULL</b>: Эта команда выполняет более интенсивный процесс очистки и компактации таблицы. Она перемещает данные из таблицы в новое физическое расположение, освобождая пространство, которое занимали удаленные строки. Однако, <b>VACUUM FULL</b> блокирует таблицу на время выполнения операции и может быть более ресурсоемкой по сравнению с обычным <b>VACUUM</b>.

* <b>VACUUM (PARALLEL n)</b>: Этап очистки индексов может выполняться в параллельном режиме. Это происходит, если на таблице создано несколько (больше одного) достаточно больших индексов: размер индекса должен превышать значение параметра `min_parallel_index_scan_size` (512 Кбайт по-умолчанию). Тогда для каждого подходящего индекса запускается отдельный рабочий процесс. Каждый индекс обрабатывается только одним рабочим процессом, то есть несколько процессов не могут очищать один и тот же индекс. Количество процессов ограничено сверху значением параметра `max_parallel_maintenance_workers` и может быть дополнительно ограничено явным указанием степени параллелизма при вызове команды `VACUUM (PARALLEL n)`.

В целом, <b>VACUUM</b> обычно достаточно для поддержания эффективности работы базы данных, однако, при необходимости выполнить более глубокую очистку и компактацию таблицы, может использоваться <b>VACUUM FULL</b>. Вариант этой команды с ключевым словом <b>CONCURRENTLY</b> работает дольше, но не блокирует индекс и не мешает чтению и обновлению данных.

Вывод данных об автоочистке:
```sql
SELECT pid, backend_start, backend_type
FROM pg_stat_activity
WHERE backend_type = 'autovacuum launcher';
```

Представление, показывающее, нужна ли таблице очистка:
```sql
CREATE VIEW needed_vacuum AS
WITH params AS (
  SELECT (SELECT setting::INT
          FROM   pg_settings
          WHERE  name = 'autovacuum_vacuum_threshold') AS vacuum_threshold,
         (SELECT setting::FLOAT
          FROM   pg_settings
          WHERE  name = 'autovacuum_vacuum_scale_factor') AS vacuum_scale_factor
)
SELECT st.relname,
       st.n_dead_tup dead_tup,
       (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::INT max_dead_tup,
       st.n_dead_tup > (p.vacuum_threshold + p.vacuum_scale_factor*c.reltuples)::INT need_vacuum,
       st.last_autovacuum
FROM   pg_stat_all_tables st,
       pg_class c,
       params p
WHERE  c.oid = st.relid
AND    c.relname = '<таблица>';
```

Аналогичное представление на определение необходимости анализа:
```sql
CREATE VIEW needed_analyze AS
WITH params AS (
  SELECT (SELECT setting::INT
          FROM   pg_settings
          WHERE  name = 'autovacuum_analyze_threshold') as analyze_threshold,
         (SELECT setting::FLOAT
          FROM   pg_settings
          WHERE  name = 'autovacuum_analyze_scale_factor') as analyze_scale_factor
)
SELECT st.relname,
       st.n_mod_since_analyze mod_tup,
       (p.analyze_threshold + p.analyze_scale_factor*c.reltuples)::INT max_mod_tup,
       st.n_mod_since_analyze > (p.analyze_threshold + p.analyze_scale_factor*c.reltuples)::INT need_analyze,
       st.last_autoanalyze
FROM   pg_stat_all_tables st,
       pg_class c,
       params p
WHERE  c.oid = st.relid
AND    c.relname = '<таблица>';
```

Основные параметры настройки автоочистки:
* `autovacuum_vacuum_scale_factor` — частота обработки
* `autovacuum_max_workers` — параллелизм
* `autovacuum_vacuum_cost_limit` — скорость работы


### Заморозка

Кроме освобождения места в страницах, очистка выполняет также задачу по предотвращению проблем, связанных с переполнением счетчика транзакций.

Заморозка (VACUUM FREEZE) в PostgreSQL - это процесс, который замораживает строки в таблицах, уменьшая или устраняя проблемы с вытеснением транзакций в базе данных. Когда строка заморожена, она больше не будет изменяться и может быть удалена или модифицирована без необходимости блокировки других транзакций.

Заморозка в PostgreSQL выполняется автоматически после того, как определенное количество транзакций прошло через таблицу. Как правило, это происходит во время процесса автовакуума, который запускается автоматически при определенных условиях.

Для настройки процесса заморозки в PostgreSQL можно использовать следующие параметры конфигурации:

`autovacuum_freeze_max_age` - это параметр, который определяет максимальный возраст строки, прежде чем она будет заморожена. По умолчанию этот параметр равен 200 миллионам транзакций.

`vacuum_freeze_table_age` - этот параметр определяет минимальный возраст строки, прежде чем она будет заморожена во время запуска команды VACUUM. По-умолчанию этот параметр равен 150 миллионам транзакций.

`vacuum_freeze_min_age` - этот параметр определяет минимальный возраст строки, прежде чем она будет заморожена во время запуска команды VACUUM. Чем меньше это значение, тем больше может быть накладных расходов. По-умолчанию этот параметр равен 50000000 транзакций.

Заморозку можно вызвать вручную командой `VACUUM FREEZE` - при этом будут заморожены все версии строк, без оглядки на возраст транзакций.


### Контрольная точка

Процесс контрольной точки ограничивает размер хранимых журнальных файлов и сокращает время восстановления. Контрольная точка и фоновая запись сбрасывают на диск  грязные буферы.

Если в работе сервера произошел сбой, при последующем запуске процесс startup обнаруживает это (в файле pg_control статус отличен от "shut down") и выполняет автоматическое восстановление.

Проверить состояние кластера:
`sudo /usr/lib/postgresql/14/bin/pg_controldata -D /var/lib/postgresql/14/main | grep state`


#### Настройка частоты контрольных точек

Сначала надо определиться, какая частота срабатываний устраивает (исходя из допустимого времени восстановления и объема журнальных файлов за это время при стандартной нагрузке). Чем реже можно позволить себе контрольные точки, тем лучше - это сокращает накладные расходы. Устраивающая частота записывается в параметр `checkpoint_timeout` (значение по-умолчанию - 5 минут - слишком мало, обычно время увеличивают до получаса). Однако возможна ситуация, когда нагрузка станет выше расчетной и за указанное время будет сгенерирован слишком большой объем журнальных записей. Для этого в параметре `max_wal_size` указывают общий допустимый объем журнальных записей. Для восстановления после сбоя сервер должен хранить файлы сmмомента последней контрольной точки, плюс файлы, накопившиеся во время работы текущей контрольной точки.

<em>Объем, указанный в параметре max_wal_size, может быть превышен. Это не жесткое ограничение, а ориентир для процесса checkpointer, влияющий на активность записи грязных буферов.</em>

* Параметр `checkpoint_warning` позволяет выводить в журнал предупреждения о слишком частом выполнении контрольных точек. Если это происходит регулярно, следует подумать об увеличении `max_wal_size` или уменьшении интервала между контрольными точками `checkpoint_timeout`.

* Включение параметра `log_checkpoints` выводит в журнал подробную информацию о каждой выполненной контрольной точке. Статистику работы процессов, записывающих грязные буферы (контрольной точки, фоновой записи и обслуживающих процессов), показывает представление `pg_stat_bgwriter`.

* Параметр `log_checkpoints` позволяет получать в журнале сообщений сервера информацию о выполняемых контрольных точках. По-умолчанию параметр выключен.


### Табличные пространства

Табличные пространства (tablespace) служат для организации физического хранения данных и определяют расположение данных в файловой системе. При инициализации кластера создаются два табичных пространства: pg_default и pg_global. Одно и то же табличное пространство может использоваться разными базами данных, а одна база данных может хранить данные в нескольких табличных пространствах.

Основные преимущества использования табличных пространств:

1. <b>Распределение данных</b>: Позволяет хранить данные на различных физических дисках или разделах дисков для более эффективного управления местом.
  
2. <b>Увеличение производительности</b>: Позволяет разместить данные на быстрых дисках или разделах, что может улучшить производительность базы данных.

3. <b>Управление местом хранения</b>: Позволяет размещать различные объекты базы данных (таблицы, индексы) в разных табличных пространствах.

В PostgreSQL можно создавать и использовать пользовательские табличные пространства для своих объектов базы данных. Например, чтобы создать табличное пространство с именем 'data_space' в каталоге '/mnt/data', можно выполнить следующий SQL запрос:

```sql
CREATE TABLESPACE data_space LOCATION '/mnt/data';
```

После создания табличного пространства, можно указывать его при создании таблиц или индексов с использованием параметра `TABLESPACE` в командах `CREATE TABLE` или `CREATE INDEX`.

Например, чтобы создать таблицу в пользовательском табличном пространстве 'data_space':
```sql
CREATE TABLE my_table 
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
) TABLESPACE data_space;
```

Таким образом, использование табличных пространств в PostgreSQL дает возможность гибко управлять распределением данных и ресурсами базы данных для оптимальной производительности и удобства администрирования.

Удалить табличное пространство если в нем есть некоторое содержимое невозможно. Для этого нужно либо удалить таблицы отдельно, либо перенести их. Чтобы перенести таблицы в табличное пространство по-умолчанию, нужно подключиться к базе данных и выполнить команду:
```sql
ALTER DATABASE db_test SET TABLESPACE pg_default;
```

Перенести все объекты в другое табличное простсранство. Перенос в другое табличное пространство - физическая операция, связанная с копированием файлов данных из каталога в каталог. На время ее выполнения доступ к перемещаемому объекту полностью блокируется:
```sql
ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;
```

Затем можно удалять пустое табличное пространство:
```sql
DROP TABLESPACE test_tablespace;
```


### Локализация

Возможности локализации позволяют хранить текст в различных кодировках. Для русского языка поддерживаются все основные кодировки символов, включая UTF8, WIN1251, KOI8R, ISO_8859_5.

PostgreSQL использует возможности локализации, предоставляемые операционной системой. Поэтому в ОС следует предварительно настроить локали, которые потребуются для работы СУБД. Обычно локали в ОС задаются в формате  "язык_территория.кодировка". Например, `ru_RU.UTF8` определяет локаль с русским языком (ru), на котором говорят в России (RU), и кодировкой UTF8. В Windows используются развернутые имена: `Russian_Russia.1251`. Язык и территория определяют такие национальные особенности, как порядок символов, формат даты, разделитель десятичных разрядови т. п.

Параметры локализации в ОС в переменных окружения:
`locale`

Параметры локали в PostgreSQL:
```sql
SELECT name, setting, context, sourcefile
FROM pg_settings
WHERE name LIKE 'lc%';
```

Формат времени:
```sql
SET lc_time = 'ru_RU.UTF8';

SELECT to_char(current_date, 'TMDay, DD TMmonth YYYY');


          to_char         
-------------------------
 Вторник, 16 января 2024
(1 row)
```


Для настройки локализации клиентского приложения нужно сделать следующее:
* Проверить, что настройки сервера корректны. Как минимум, что используется правильная кодировка базы данных (неизменяемый параметр `server_encoding` покажет кодировку, заданную при создании базы данных).
* Проверить, что в клиентской ОС установлены нужные локали, и настроить категории локали (переменные среды LC_*) в сеансе ОС. 
* Настроить кодировку, с которой работает приложение, и проверить настройки устройства вывода. Например, psql в Windows обычно использует кодировку Win-1251, поэтому в терминале (cmd.exe) необходимо выполнить команду `chcp 1251` и установить шрифт `true type` (например, Lucida Console).
* После подключения к базе данных проверить параметр `client_encoding`. Этот параметр отвечает за перекодировку символов между клиентом и сервером. При необходимости установить в значение кодировки приложения.


### Резервное копирование

Резервное копирование - это процесс создания резервных копий данных и хранения их для предотвращения потери важных данных в случае сбоя или ошибки. Резервное копирование обычно используется для восстановления данных в случае катастрофической потери данных.

Все команды выполняются от имени postgres.


### Логическая копия

<b>Логическое резервирование</b> — это набор команд SQL, восстанавливающих кластер (или базу данных, или отдельный объект) с нуля. Такая копия представляет собой, по сути, обычный текстовый файл, что дает известную гибкость (команды SQL можно выполнить на другой версии СУБД (при наличии совместимости на уровне команд) или на другой архитектуре (то есть не требуется двоичная совместимость)). Однако для большой базы этот механизм неэффективен, поскольку выполнение команд займет много времени. К тому же восстановить систему из такой резервной копии можно только на тот момент, в который она была сделана.

* <b>COPY</b> 
COPY используется для копирования данных между таблицей и файлом или между таблицей и другой таблицей. Эта команда предоставляет отличную производительность при загрузке или выгрузке большого объема данных.

Копирование данных из файла в таблицу:
```sql
COPY employees FROM '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

Копирование данных из таблицы в файл (файл должен быть создан):
```sql
COPY employees TO '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

DELIMITER ',' указывает, что данные в файле разделены запятыми, и CSV HEADER указывает, что первая строка содержит заголовки столбцов.

Параметры COPY могут включать опции формата данных (CSV, TEXT), разделитель, заголовки, игнорирование ошибок и другие. Кроме того, с помощью COPY можно копировать данные между таблицами, указывая имя целевой таблицы вместо имени файла:
```sql
COPY employees TO employees_copy;
```

Копирование данных из запроса в таблицу c наличием условия:
```sql
COPY (SELECT * FROM table) TO any_table WHERE id != 1;
```


* <b>pg_dump</b>
Выгружает базу данных в виде скрипта или в архивном формате. `pg_dump` — это программа для создания резервных копий базы данных PostgreSQL. Она создаёт целостные копии, даже если база параллельно используется. Программа `pg_dump` не препятствует доступу других пользователей к базе данных (ни для чтения, ни для записи).

По-умолчанию, файл с дампом будет создан в рабочем каталоге, из которого выполняется команда. Также можно указать абсолютный путь до файла вместо просто имени файла.

Выгрузка в SQL:
`pg_dump -h hostname -U dbuser -f dump.sql dbname`

Восстановление дампа:
`sudo -u postgres psql -d dbname -f dump.sql`

База данных не создастся данной командой. Базу данных нужно предварительно создать в psql от template0. Также к моменту восстановления дампа должны уже существовать все пользователи, которые имели права на объекты, иначе произойдет ошибка.

`--create`  cформировать в начале вывода команду для создания базы данных и затем подключения к ней 

`--file=файл`   отправить вывод в указанный файл

`--format=формат`   

По-умолчанию действует формат `plain`. Серьезное ограничение этого формата состоит в том, что выбирать объекты нужно в момент выгрузки. 
Формат `custom` позволяет сначала сделать полную копию, а выбирать объекты уже при загрузке. 
Формат `directory` интересен тем, что позволяет выгружать данные в несколько параллельных потоков. При этом гарантируется согласованность данных: все потоки будут использовать один и тот же снимок данных.


* <b>pg_dumpall</b>
Создает резервную копию всего кластера баз данных, включая все роли и табличные пространства. Поскольку pg_dumpall требуется доступ ко всем объектам всех БД, запускать ее следует суперпользователю или пользователю, включенному в предустановленную роль pg_read_all_data. Результатом работы pg_dumpall является скрипт для psql. Другие форматы не поддерживаются.

Дамп всего кластера:
`pg_dumpall -U postgres -f dumpall.sql`

Восстановлени полученной копии:
`sudo -u postgres psql -f dumpall.sql postgres`


Дамп со сжатием:
`pg_dump db_name | gzip > filename.gz`

`gunzip -c filename.gz | psql db_name`


`sudo -u postgres pg_dump -d test_db --table=t | psql -d test_db2`  копирование таблицы с содержимым в другую базу данных

`sudo -u postgres pg_dump -d test_db --create`  копия базы данных в виде SQL-скрипта, которая выводится в консоль (stdin)

<em>В базах данных в таблицах могут быть определены политики защиты строк, поэтому есть опасность выгрузить не все данные и даже не узнать об этом. Чтобы обойти политики защиты строк перед выгрузкой данных нужно применить к ролям, с которых происходит выгрузка, `BYPASSRLS`:</em>
```sql
ALTER ROLE dump_user BYPASSRLS;
```

<em>`pg_dumpall` не поддерживает параллельную выгрузку данных, но можно с помощью `pg_dumpall` с ключем --globals-only выгрузить роли и табличные пространства, а сами базы выгрузить в помощью `pg_dump` в параллельном режиме.</em>


* <b>pg_restore</b>
Утилита командной строки, предназначенная для восстановления резервной копии. Она позволяет восстановить базу данных из архивного файла, который был создан с помощью pg_dump.

Восстановление базы данных из архивного файла:
`pg_restore -d dbname filename`


Восстановление только схемы базы данных (эта команда восстановит только структуру базы данных без данных):
`pg_restore -s -d dbname filename`


Восстановление только данных без схемы (эта команда загрузит только данные в базу данных без создания таблиц и других объектов):
`pg_restore -a -d dbname filename`


Восстановление базы данных с кастомными параметрами:
`pg_restore -C -d dbname -h localhost -U username filename`

<em>Если в pg_dump, pg_dumpall и pg_restore не указывать параметр -h (хост), то подключение будет происходить по localhost.</em>

<em>После восстановления базы имеет смысл выполнить команду `ANALYZE`, которая соберет статистику.</em>


### Физическая копия

<b>Физическое резервирование</b> предполагает создание копии файловой системы (ФС). 

* Если копия создается при выключенном сервере, она называется `холодной`. Такая копия либо содержит согласованные данные (если сервер был выключен аккуратно), либо содержит все необходимые для восстановления журналы (например, если используется снимок данных  средствами операционной системы). Это упрощает восстановление, но требует останова сервера.

* Если копия создается при работающем сервере, она называется `горячей`. При горячем резервировании копия ФС будет содержать несогласованные данные. Однако механизм восстановления после сбоев можно успешно применить и к восстановлению из резервной копии. Для этого потребуются журналы предзаписи как минимум за время копирования файлов.

Для создания горячей резервной копии существует утилита `pg_basebackup`. Вначале утилита выполняет контрольную точку, затем копируется файловая система кластера. Все файлы WAL, сгенерированные сервером за время от контрольной точки до окончания копирования файлов, также копируются в резервную копию. Такая копия называется автономной, поскольку содержит в себе все необходимое для восстановления. Для восстановления достаточно развернуть резервную копию и запустить сервер. При необходимости он выполнит восстановление согласованности с помощью имеющихся файлов WAL и будет готов к работе.

Чтобы сохранить все необходимые для восстановления файлы WAL, сгенерированные сервером за время копирования файлов, утилита подключается к серверу по специальному протоколу репликации. Несмотря на название, это протокол используется не только для репликации, но и для резервного копирования. Протокол позволяет получать поток журнальных записей параллельно с копированием файлов. 

Чтобы сервер не удалил необходимые файлы WAL преждевременно, может использоваться слот репликации. Для того, чтобы подключение было возможно, необходим ряд настроек. 

* Во-первых, роль должна обладать атрибутом `REPLICATION` (или быть суперпользователем). Кроме того, этой роли должно быть выдано разрешение в конфигурационном файле <b>pg_hba.conf</b>.

* Во-вторых, параметр `max_wal_senders` должен быть установлен в достаточно большое значение. Этот параметр ограничивает число одновременно работающих процессов `wal_sender`, обслуживающих подключения по протоколу репликации.

* В-третьих, параметр `wal_level`, определяющий количество информации в журнале, должен быть установлен в значение `replica`. 


> <b><em>Принципиальная особенность протокола репликации заключается в том, что он позволяет получать поток журнальных записей параллельно с копированием файлов.</em></b>


### Обновление PostgreSQL

Для того чтобы обновить сервер до очередного дополнительного выпуска, требуется:
1. <b>Установить новые исполняемые файлы</b>. Если PostgreSQL был установлен из пакета, необходимо установить новые версии пакетов (сервер, клиент, расширения). Некоторые пакетные менеджеры, в частности, `apt` в Ubuntu, по умолчанию автоматически перезапускают сервер. Если PostgreSQL был собран из исходных кодов, необходимо выполнить `make install`.
2. <b>Перезапустить сервер</b>. После перезапуска он продолжит работу уже на новой версии. Обслуживание клиентов прерывается на время, требуемое для перезапуска. 
3. После перезапуска может быть нужно обновить расширения (`ALTER EXTENSION … UPDATE`) и выполнить дополнительные действия, указанные в "Замечаниях к выпуску".

#### Методы обновления

* <b>sudo apt upgrade postgresql-14</b>

  При таком обновлении сервер автоматически перезапускается, что может быть неудобно. Это поведение настраивается, подробности описаны в справочной странице по команде `needrestart`.

* <b>pg_upgrade</b>

  Утилита `pg_upgrade` выполняет резервную копию каталога и схем данных всех баз с помощью утилит `pg_dump` и `pg_dumpall` в режиме --binary-upgrade. Затем эти объекты восстанавливаются на новом сервере с помощью `pg_restore`. Все эти действия выполняются достаточно быстро — время не зависитот объема данных в кластере. Затем выполняется перенос пользовательских данных.

  Порядок действий:
  1. Установить новый сервер, инициализировать (но не запускать) кластер PostgreSQL.
  2. Старый сервер останавливается, запускается утилита `pg_upgrade`.

  <em>Новый кластер должен быть инициализирован с той же локалью, что и старый.</em>

  Утилита в процессе работы запускает и останавливает серверы, и для этого нужно, чтобы к обоим кластерам у нее был локальный суперпользовательский доступ. У нас такой доступ есть, а в общем случае может потребоваться временно изменить файл `pg_hba.conf`.

  Проверка совместимости для обновления базы данных PostgreSQL с версии 13 на версию 14:
  `/usr/lib/postgresql/14/bin/pg_upgrade --check --link -b /usr/lib/postgresql/13/bin/ -B /usr/lib/postgresql/14/bin/ -d /etc/postgresql/13/prod -D /etc/postgresql/14/prod`

  Обновление в режиме создания ссылок:
  `/usr/lib/postgresql/14/bin/pg_upgrade --link -b /usr/lib/postgresql/13/bin/ -B /usr/lib/postgresql/14/bin/ -d /etc/postgresql/13/prod -D /etc/postgresql/14/prod`

  <b>Нельзя обновлять таким способом реплики. Приводит к потере данных.</b>


-------------------------------------------------------------------------------------------------------

### Инструменты администрирования PostgreSQL

#### Zabbix

Zabbix - это мониторинговая система с открытым исходным кодом, которая предназначена для отслеживания состояния различных систем и устройств в реальном времени. Она позволяет контролировать производительность и доступность различных сервисов, приложений и устройств, а также проводить анализ данных и сбор статистики.

В администрировании баз данных Zabbix может быть использован для мониторинга производительности серверов баз данных, контроля доступности и работы баз данных, а также для отслеживания различных параметров, таких как загрузка процессора, использование памяти, количество соединений и другие.

Для использования Zabbix в администрировании баз данных необходимо установить и настроить программное обеспечение на сервере, где расположена база данных. Затем создать мониторинговые элементы, которые будут отслеживать нужные параметры базы данных, настроить уведомления о возможных проблемах и настроить отчеты и графики для анализа данных.

Таким образом, Zabbix может значительно облегчить работу администратора баз данных, позволяя быстро выявлять и устранять проблемы, следить за производительностью и доступностью баз данных и улучшать работу всей системы.


#### Grafana

Grafana - это платформа для визуализации данных и мониторинга систем. Она позволяет создавать графики, диаграммы и панели для отображения различных метрик и данных на основе источников данных. Grafana поддерживает множество различных источников данных, включая базы данных, облачные сервисы, инструменты мониторинга и др.

В администрировании баз данных Grafana может быть использована для мониторинга и визуализации различных метрик и показателей производительности баз данных. Например, можно создать дашборд для отслеживания загрузки CPU, оперативной памяти, использования дискового пространства, количества запросов и других параметров баз данных.

Администраторы баз данных могут использовать Grafana для отслеживания производительности баз данных, выявления проблем, оптимизации запросов и принятия обоснованных решений на основе данных. Дополнительно, с помощью Grafana можно создавать оповещения и уведомления о превышении установленных пороговых значений, что поможет оперативно реагировать на проблемы с базой данных.


#### Patroni

Patroni - это высокодоступное решение для управления кластерами баз данных PostgreSQL. Он был разработан для обеспечения автоматического восстановления и обеспечения остановки базы данных без участия администратора. 

Patroni работает путем мониторинга состояния кластера баз данных и принятия решений о переключении ролей между узлами в случае отказа одного из них. Он предоставляет возможность автоматического переноса мастер-репликации между узлами, а также автоматического восстановления после сбоя.

Для использования Patroni в разработке и администрировании баз данных необходимо установить и настроить его на каждом узле кластера PostgreSQL. После этого Patroni будет автоматически мониторить состояние базы данных и принимать необходимые действия в случае возникновения проблем.

Patroni также предоставляет механизмы для управления конфигурациями базы данных, масштабирования кластеров и резервного копирования данных. Он полезен как для разработчиков, так и для администраторов баз данных, позволяя им управлять высокодоступными кластерами PostgreSQL с минимальными усилиями.