# Администрирование СУБД PostgreSQL


<div>
    <img src="https://github.com/devicons/devicon/blob/master/icons/linux/linux-original.svg" width="40" height="40"/>&nbsp;
    <img src="https://github.com/devicons/devicon/blob/master/icons/postgresql/postgresql-original.svg" width="40" height="40"/>&nbsp;
</div>


### Установка и использование PostgreSQL в Linux

<b>PostgreSQL</b> — программа, которая относится к классу <em>систем управления базами данных</em>. Когда эта программа выполняется, она становится <em>сервером PostgreSQL</em> или <em>экземпляром сервера</em>. Данные, которыми управляет PostgreSQL, хранятся в базах данных. Один экземпляр PostgreSQL одновременно работает с несколькими базами данных. Этот набор баз данных называется <em>кластером баз данных</em>.

* <b>Кластер баз данных</b> - это данные в файлах; 
* <b>Cервер или экземпляр сервера</b> - программа, управляющая кластером баз данных.

[Источник пакетной установки PostgreSQL](https://www.postgresql.org/download/)

<em>Здесь и далее рассматривается пакет PostgreSQL 14.11 для Ubuntu.</em>


Для инициализации кластера в Ubuntu создана обертка `pg_createcluster` над утилитой `initdb`. Эта утилита автоматически запускается при установке пакета и создает кластер баз данных с именем "main". Стоит обратить внимание, что инициализация кластера проходит с отключенным подсчетом контрольных сумм в страницах данных.Исполняемые файлы, файлы конфигурации и журнал сервера размещены в соответствии с правилами, принятыми в Ubuntu. Кроме того, настраивается автоматический запуск и останов сервера PostgreSQL при запуске и останове операционной системы.

Для удаления кластера используется утилита `pg_dropcluster`. Утилиты `pg_createcluster` и `pg_dropcluster` специфичны для Ubuntu. В других системах нужно явно инициализировать кластер с помощью `initdb` и задействовать подходящие средства операционной системы.

К основным операциям управления сервером относятся запуск и останов сервера, получение текущего статуса сервера, обновление конфигурации и некоторые другие. Для выполнения этих действий предназначена утилита `pg_ctl`, идущая в составе PostgreSQL. Но в пакетном дистрибутиве для `Ubuntu` доступ к утилите `pg_ctl` осуществляется не напрямую, а через специальную обертку `pg_ctlcluster`. В других системах утилита pg_ctl может использоваться непосредственно.

`sudo pg_ctlcluster 14 main status`     получить текущий статус сервера

`sudo pg_ctlcluster 14 main start`      запустить сервер

`sudo pg_ctlcluster 14 main stop`       остановить сервер

`sudo pg_ctlcluster 14 main restart`    переапустить сервер


##### Расчет контрольных сумм

Контроль расчетных сумм в PostgreSQL необходим для обеспечения правильности данных, а также для обнаружения любых возможных ошибок или несоответствий в базе данных. Это позволяет избежать потенциальных проблем, связанных с неверными результатами вычислений или сбоями в программном обеспечении. Такой контроль также помогает обнаруживать несанкционированные изменения данных и предотвращать возможные атаки на систему.

Перед проверкой нужно отключить сервер PostgreSQL.

`sudo /usr/lib/postgresql/14/bin/pg_checksums --check -D /var/lib/postgresql/14/main`   узнать, включен ли расчет контрольных сумм

`sudo /usr/lib/postgresql/14/bin/pg_checksums --enable -D /var/lib/postgresql/14/main`      включение расчета контрольных сумм

После включения подсчета контрольных сумм сервер нужно запустить.


### Основные команды PostgreSQL в терминале Linux

`sudo apt-get --purge remove postgresql\*`  удаление PostgreSQL и всех его компонентов

`sudo apt install postgresql`   установка PostgreSQL

`sudo ls -l /usr/lib/postgresql/14/bin`     каталог установки PostgreSQL

`sudo service postgresql status`    проверка, запущен ли сервис

`sudo service postgresql start`     запуск сервера если он не запущен

`sudo service postgresql restart`   перезапуск сервера postgresql

`sudo service postgresql stop`  остановка сервера postgresql

`sudo service postgresql stop -m immediate --skip systemctl-redirect`   остановка сервера postgresql без выполнения контрольной точки

`sudo pg_isready`       проверка, готов ли сервер postgresql принимать подключение от клиентов

`sudo -u postgres psql`     подключение к серверу, активация оболочки <b>psql</b>

`psql -h localhost -U user_name -d db_name`     подключение по локальной сети к базе данных под определенным пользователем

`psql -h localhost -U user_name -d db_name -c "SELECT * FROM table" > /path/to/file/output.txt`     запись результата запроса в файл

`psql < filename` или `psql -f filename`    выполнение файла

`sudo tail -n 10 /var/log/postgresql/postgresql-14-main.log`    вывод 10 последних записей из журнала сообщений сервера

`\q`    выход из <b>psql</b>


### Установка pgAdmin4

1. Установка из репозитория <b>pgAdmin4 APT</b>:

`curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key add`

`sudo sh -c 'echo "deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/$(lsb_release -cs) pgadmin4 main" > /etc/apt/sources.list.d/pgadmin4.list && apt update'`

2. Запуск установки <b>pgAdmin4</b>:

`sudo apt install pgadmin4`

3. Запуск скрипта, устанавливающего веб-компоненты. Скрипт находится по адресу `/usr/pgadmin4/bin/setup-web.sh`.

4. В процессе установки будет перезапущена служба Apache2. После завершения работы скрипта необходимо добавить разрешение для Apache2 на доступ через брэндмауэр:

`sudo ufw allow 'Apache'`

5. Запуск брэндмауэра:

`sudo ufw enable`

6. Убедиться, что Apache2 включена в список разрешенных в брэндмауэре:

`sudo ufw status`

7. Для доступа к веб-версии pgAdmin4 ввести в браузере:

`http://<ip-адрес:порт>/pgadmin4`


### Основные команды PSQL

`\! clear`  очистить терминал

`\l`    список баз данных

`\c <db_name>`  подключение к базе данных

`\x`    смена формата вывода результатов запросов (вертикально/горизонтально)

`\dt`   список таблиц базы данных

`\dt <schema_name>.*`   список таблиц определенной схемы

`\du`   список пользователей

`\dn`   список схем базы данных

`\dL`   список установленных языков программирования

`\df`   список функций и процедур базы данных

`\dx`   список расширений базы данных

`\dT`   список составных типов базы данных

`\db`   список табличных пространств

`\dRp+`     список публикаций для логической репликации

`\dew`      список оберток внешних данных

`\des+`     список внешних серверов

`\det`      список внешних таблиц

`\dp <username>.<table>`    список привелегий для таблицы у пользователя

`\i <path_to_file_sql>`    открытие файла (используется для запуска скриптов .sql)

`\gx`   расширенный режим отображения, только для одного запроса (ставится вместо точки с запятой)

`\timing on`  включение счетчика времени выполнения запросов


##### Запись результатов запроса в файл

`\o output.txt`     создание файла

`SELECT schemaname, tablename, tableowner FROM pg_tables LIMIT 5;`

`\! cat output.txt`


### Конфиурирование сервера PostgreSQL

Вывод всех незакоментированных параметров конфигурации из файла `postgresql.conf`:
```sql
SELECT sourceline, name, setting, applied
FROM pg_file_settings
WHERE sourcefile LIKE '/etc/postgresql/14/main/postgresql.conf';
```

Вывод действующих значений параметров из представления `pg_settings`:
```sql
SELECT name, setting, unit,
  boot_val, reset_val,
  source, sourcefile, sourceline,
  pending_restart, context
FROM pg_settings
WHERE name = '<параметр>'\gx
```

Ключевые колонки представления `pg_settings`:
* <b>name</b>, <b>setting</b>, <b>unit</b> — название и значение параметра;
* <b>boot_val</b> — значение по умолчанию;
* <b>reset_val</b> — значение, которое восстановит команда RESET;
* <b>source</b> — источник текущего значения параметра;
* <b>pending_restart</b> — значение изменено в файле конфигурации, но для применения требуется перезапуск сервера.

Столбец `context` определяет действия, необходимые для применения параметра. Среди возможных значений:
* <em>internal</em> — изменить нельзя, значение задано при установке;
* <em>postmaster</em> — требуется перезапуск сервера;
* <em>sighup</em> — требуется перечитать файлы конфигурации;
* <em>superuser</em> — суперпользователь может изменить для своего сеанса;
* <em>user</em> — любой пользователь может изменить для своего сеанса.


Перезагрузить файл конфигурации postgresql.conf без остановки сервера базы данных:
```sql
SELECT pg_reload_conf();
```


#### postgresql.auto.conf

Файл конфигурации, управляемый командами SQL. Этот файл не следует изменять вручную. Для его редактирования предназначена команда `ALTER SYSTEM`. По сути, эта команда представляет собой SQL-интерфейс для управления параметрами конфигурации.

Для применения изменений, сделанных командой `ALTER SYSTEM`, сервер должен перечитать конфигурационные файлы, как и в случае с изменением файла postgresql.conf. Содержимое обоих файлов (postgresql.conf и postgresql.auto.conf) можно увидеть через представление `pg_file_settings`. А актуальные значения параметров — в представлении `pg_settings`.

```sql
ALTER SYSTEM SET port TO 5433;
```
или
```sql
SELECT set_config('port', 5433, false);
```

Третий параметр функции `set_config` говорит о том, нужно ли устанавливать значение только для текущей транзакции (true) или до конца работы сеанса (false). Это важно при работе приложения через пул соединений, когда в одном сеансе могут выполняться транзакции разных пользователей.


```sql
SHOW port;
```
или
```sql
SELECT current_setting('port');
```

`ALTER SYSTEM RESET <параметр>`     удаляет строку

`ALTER SYSTEM RESET ALL`    удаляет все строки из postgresql.auto.conf


Процесс изменения параметра `work_mem`:
```sql
ALTER SYSTEM SET work_mem TO '128MB';

SELECT pg_reload_conf();
```

Установка параметров внутри транзакции:
```sql
BEGIN;
SET LOCAL work_mem TO '64MB'; 
SHOW work_mem;

 work_mem 
----------
 64MB
(1 row)

COMMIT;

SHOW work_mem;

 work_mem 
----------
 8MB
(1 row)
```

<em>После завершения транзакции значения восстанавливаются. </em>


### Мониторинг

PostgreSQL работает под управлением операционной системы ив известной степени зависит от ее настроек.

Отображение серверных процессов, связанных с postgres (ввод в терминале ОС):
`ps auxww | grep ^postgres`

Каждый обслуживающий процесс собирает необходимую статистику в рамках каждой выполняемой транзакции. Затем эта статистика передается процессу-коллектору. Коллектор собирает и агрегирует статистику со всех обслуживающих процессов. Раз в полсекунды (время настраивается при компиляции) коллектор сбрасывает статистику во временные файлы в каталог `PGDATA/pg_stat_tmp`. Поэтому перенесение этого каталога в файловую систему в памяти может положительно сказаться на производительности. 

Когда обслуживающий процесс запрашивает информацию о статистике (через представления или функции), в его память читается последняя доступная версия статистики — это называется снимком статистики. Если не попросить явно, снимок не будет перечитываться до конца транзакции, чтобы обеспечить согласованность.

При останове сервера коллектор сбрасывает статистику в постоянные файлы в каталог PGDATA/pg_stat. Таким образом, статистика сохраняется при перезапуске сервера. Обнуление счетчиков происходит по команде администратора, а также при восстановлении сервера после сбоя.


[Функции для системного администрирования](https://postgrespro.ru/docs/postgresql/13/functions-admin#FUNCTIONS-ADMIN-DBSIZE)


Просмотр глобальной статистики по всей базе данных:
```sql
SELECT *
FROM pg_stat_database
WHERE datname = 'admin_monitoring' \gx
```

Просмотр информации об обслуживающих процессах (pg_stat_activity):
```sql
SELECT pid, query, state, wait_event, wait_event_type, pg_blocking_pids(pid)
FROM pg_stat_activity
WHERE backend_type = 'client backend' \gx
```

<em>Состояние `idle in transaction` означает, что сеанс начал транзакцию, но в настоящее время ничего не делает, а транзакция осталась незавершенной. Это может стать проблемой, если ситуация возникает систематически (например, из-за некорректной реализации приложения или из-за ошибок в драйвере), поскольку открытый сеанс удерживает снимок данных и таким образом препятствует очистке.</em>


#### Завершение блокирующего сеанса вручную

Сначала нужно узнать номер заблокированного процесса при помощи функции `pg_blocking_pids`:
```sql
SELECT pid AS blocked_pid
FROM pg_stat_activity
WHERE backend_type = 'client backend'
AND cardinality(pg_blocking_pids(pid)) > 0;
```

Прерывание сеанса вызовом `pg_terminate_backend` (pid 16783 указан в качестве примера):
```sql
SELECT pg_terminate_backend(b.pid)
FROM unnest(pg_blocking_pids(16783)) AS b(pid);
```


### Роли и привилегии

Роль - пользователь СУБД. Роль не связана с пользователем ОС, она определяется на уровне кластера.

`CREATE ROLE <роль> [WITH] <атрибут> [атрибут ...]`

<em>LOGIN</em>   возможность подключения

<em>SUPERUSER</em>   суперпользователь

<em>CREATEDB</em>    возможность создавать базы данных

<em>CREATEROLE</em>  возможность создавать роли

<em>REPLICATION</em>     использование протокола репликации

и др.

Создание базы данных
```sql
CREATE DATABASE access_roles;`
```

Подключение к базе данных
`\c access_roles`

Создаем роль для пользователя alice (появляется возможность подключаться и создавать новые роли)
```sql
CREATE ROLE alice LOGIN CREATEROLE;
```

Подключение к базе данных под именем alice

\с - alice

или

`psql -h localhost -U alice acces_roles`

Создание новой роли от alice
```sql
CREATE ROLE bob LOGIN;
```

##### Предопределенные роли

`pg_read_all_settings`  чтение всех параметров сервера

`pg_read_all_stats`     доступ к статистике

`pg_stat_scan_tables`   мониторинг и блокировки таблиц

`pg_read_all_data`      чтение данных из всех таблиц

`pg_write_all_data`     изменение данных во всех таблицах

`pg_read_server_files`      чтение файлов на сервере

`pg_write_server_files`     запись в файлы на сервере

`pg_execute_server_programs`    выполнение программ на сервере


Когда роль создает в базе данных какие-либо объекты, она становится их владельцем. На самом деле владельцами считаются также и роли, включенные в создавшую объект роль.

Передача объектов alice bob`у
`REASSIGN OWNED BY alice TO bob;`


##### Примеры использования управления привилегиями

`CREATE ROLE new_user WITH LOGIN PASSWORD 'new_password' VALID UNTIL '2022-12-31';`      создание пользователя и пароля и установление срока учетной записи

`GRANT ALL PRIVILEGES ON DATABASE your_database TO your_username;`      предоставление привилегий новому пользователю

`GRANT CREATE, USAGE ON SCHEMA alice TO bob WITH GRANT OPTION`    предоставление привилегий пользователю bob на создание и использование схем с правом передачи

`REVOKE ALL ON  table FROM bob CASCADE;`    отзыв всех привелегий на таблицу table у bob'а и других ролей в иерархии

`ALTER ROLE your_username NOLOGIN;`     лишение пользователя возможности подключения в базе данных

`GRANT alice TO postgres;`   включение alice в роль postgres

`REVOKE alice TO postgres;`  исключение alice из роли postgres

`ALTER FUNCTION function() SECURITY DEFINER;`   объявление функции как работающей с правами создавшей ее роли


##### Access privileges

* a - INSERT
* r - SELECT
* w - UPDATE
* d - DELETE
* D - TRUNCATE
* x - REFERENCE
* t - TRIGGER


### Политики защиты строк (row-level security policies)

Политики защиты строк (row-level security, RLS) позволяют управлять доступом к таблице на уровне отдельных строк. Политика определяет возможность выборки или изменения строк таблицы с помощью двух предикатов (логических выражений), которые вычисляются для каждой строки запроса. Результаты говорят о том, может ли пользователь видеть или менять строку.

Чтобы политики защиты строк начали работать, нужно явно включить этот механизм для каждой таблицы.

Политики не применяются для суперпользователя и для ролей с атрибутом `BYPASSRLS`.

На одной таблице можно определить несколько политик. В этом случае будут учитываться все предикаты. По-умолчанию создаются разрешительные (PERMISSIVE) политики. Чтобы строка была доступна, достаточно, чтобы хотя бы один из предикатов этих политик был истинен. Но если на таблице включена защита строк, и при этом не определено ни одной разрешительной политики, не будет доступна ни одна строка. Дополнительно можно создать и ограничительные (RESTRICTED) политики. Если они заданы, то все их предикаты должны быть истинны.

Некоторые из операторов управления RLS:
`USING` используется для определения условия, при котором политика защиты строки будет применяться.
`WITH CHECK` определяет условие, которое должно быть выполнено при вставке новой строки или обновлении существующей строки. 
`TO` определяет, кому будет применяться данная политика защиты строки.

<b><em>Применение политики защиты строк на примере таблицы, где для разных ролей доступна видимость разной категории строк:</em></b>

```sql
-- Создание таблицы
CREATE TABLE new_table 
(
  category INTEGER,
  text_column TEXT
);


-- Выдача привелегий пользователям
GRANT SELECT ON new_table TO alice, bob;


-- RLS для alice
CREATE POLICY select_category_1_policy
ON new_table
FOR SELECT
USING (category = 1)
WITH CHECK (category = 1) 
TO alice;

-- RLS для bob
CREATE POLICY select_category_2_policy
ON new_table
FOR SELECT
USING (category = 2)
WITH CHECK (category = 2) 
TO bob;


--Включение защиты на уровне строк для таблицы
ALTER TABLE new_table ENABLE ROW LEVEL SECURITY;
```


### Подключение и аутентификация

<b>Идендификация</b> - определение имени пользователя базы данных
<b>Аутентификация</b> - действительно ли пользователь тот, за кого себя выдает (пароль)
<b>Авторизация</b> - имеет ли данный пользователь право подключаться к серверу (функционал привилегий)

Настройки аутентификации хранятся в конфигурационном файле, который называется `pg_hba.conf`. Он состоит из строк, каждая из которых считается отдельной записью. Пустые строки и комментарии (все после символа #) игнорируются. Строка состоит из полей, разделенных пробелами или табуляциями.

Конфигурационный файл обрабатывается сверху вниз. Для каждой строки определяется, подходит ли она к запрашиваемому клиентом подключению (по соответствию типа подключения, имени БД, имени пользователя и IP-адресу). Если подходит, то выполняется аутентификация указанным в строке методом. Если результат успешен, то подключение разрешается, иначе — запрещается (другие строки при этом уже не рассматриваются). Если ни одна из строк не подошла, то доступ запрещается. Таким образом, записи в файле должны идти сверху вниз от частногок общему.

Узнать используемый в СУБД на данный момент метод шифрования паролей:
```sql
SHOW password_encryption;
```

Сохранить исходный файл перед изменением:
`sudo cp -n /etc/postgresql/13/main/pg_hba.conf ~/pg_hba.conf.orig`

Редактировать файл pg_hba.conf, добавить следующую строку:
`local all postgres trust`

Чтобы применить изменения, нужно перечитать конфигурационный файл:
```sql
SELECT pg_reload_conf();
```

Восстановление исходныx настроек:
`sudo cp ~/pg_hba.conf.orig /etc/postgresql/13/main/pg_hba.conf`

Рестарт сервера:
`sudo pg_ctlcluster 14 main restart`


##### pg_ident.conf

Правила сопоставления имен определяются в отдельном файле `pg_ident.conf`; его расположение определяется параметром `ident_file`. Файл имеет такую же структуру, как и pg_hba.conf. Записи состоят из трех полей: название соответствия, внешнее имя (имя пользователя ОС), внутреннее имя (роль PostgreSQL).


### Очистка дискового пространства

Задачи, требующие периодического выполнения:

1. <b>Очистка страниц от исторических данных,которые образуются из-за многоверсионности:</b>
Механизм многоверсионности позволяет эффективно реализовать изоляцию на основе снимков, но в результате в табличных страницах  накапливаются старые версии строк, а в страницах индексов — ссылки на эти версии. 

<em>Если своевременно не вычищать исторические данные, таблицы и индексы будут неконтролируемо разрастаться и поиск в них актуальных версий строк будет замедляться.</em>


2. <b>Очистка карты видимости:</b>
В карте видимости отмечены страницы, которые содержат только актуальные версии строк, видимые во всех снимках данных. Иными словами, это страницы, которые давно не изменялись и успели полностью очиститься от неактуальных версий.

Карта видимости применяется:
* Для оптимизации очистки. В отмеченные страницы очистке не надо заглядывать — в них не может быть мертвых версий.
* Для ускорения доступа только по индексу.

<em>Если не обновлять карту видимости, индексный доступ будет работать менее эффективно.</em>


3. <b>Обновление карты свободного пространства:</b>
В карте свободного пространства отмечено наличие пустого места внутри страниц. Карта используется при вставке новых версий строк, чтобы быстро найти подходящую страницу, на которую поместятся добавляемые данные. 

<em>Если периодически не обновлять карту свободного пространства, то с течением времени может произойти фрагментация данных на диске. Это может привести к снижению производительности базы данных, так как СУБД не сможет эффективно управлять свободным пространством и выполнять операции вставки, обновления и удаления данных.</em>


4. <b>Обновление статистики:</b>
Для работы оптимизатора запросов необходима статистическая информация о данных, такая как количество строкв таблицах и распределение данных в столбцах.

<em>Если не обновлять статистику, она перестанет соответствовать реальным данным и оптимизатор станет строить плохие планы выполнения. Из-за этого запросы могут начать выполняться на порядки медленнее, чем могли бы.</em>


5. <b>Заморозка:</b>
Достаточно старые версии строк должны помечаться как "замороженные". Такой признак говорит о том, что версия строки появилась так давно, что номер создавшей ее транзакции больше не имеет значения и его можно использовать повторно.

<em>Если не выполнять заморозку своевременно, сервер не сможет выделить очередной номер транзакции. Это аварийная ситуация: сервер остановится, все незавершенные транзакции оборвутся. После этого администратор должен будет вручную стартовать сервер и выполнить заморозку.</em>


<b>Выполнение всех описанных выше периодических задач обслуживания берет на себя фоновый процесс автоочистки (autovacuum).</b> 

В системе постоянно присутствует процесс `autovacuum launcher`, который планирует работу очистки и запускает необходимое число рабочих процессов `autovacuum worker`, работающих параллельно. Очистка работает постранично, не приводя к блокировкам других транзакций, хотя и создает нагрузку на подсистему ввода-вывода.

Автоматическая очистка перестанет работать при отключении любого из двух параметров `autovacuum` или `track_counts`. Может ошибочно показаться, что отключение способно увеличить производительность системы за счет исключения "лишних" операций ввода-вывода. На самом деле отказ от очистки влечет за собой последствия: неконтролируемое разрастание файлов, замедление запросов и риск аварийной остановки сервера. В конечном итоге это приведет к полному параличу системы.


* <b>VACUUM</b> [таблица]: Эта команда выполняет процесс автоматического освобождения пространства в таблицах, которое было выделено для удаленных, обновленных или вставленных строк. Она также обновляет статистику таблицы, которая используется оптимизатором запросов для выбора наиболее эффективных планов выполнения запросов.

<em>`VACUUM` как одиночный параметр запускает процесс очистки всей базы данных.</em>

* <b>VACUUM VERBOSE</b>: Параметр VERBOSE указывает на то, что при выполнении операции VACUUM будет выводиться более подробная информация о процессе. Это может включать в себя данные о количестве освобожденного пространства, времени выполнения операции, а также другие дополнительные сведения. Указание параметра VERBOSE делает вывод информации более информативным и обычно используется для отслеживания прогресса операции и оценки ее эффективности.

* <b>VACUUM FULL</b>: Эта команда выполняет более интенсивный процесс очистки и компактации таблицы. Она перемещает данные из таблицы в новое физическое расположение, освобождая пространство, которое занимали удаленные строки. Однако, <b>VACUUM FULL</b> блокирует таблицу на время выполнения операции и может быть более ресурсоемкой по сравнению с обычным <b>VACUUM</b>.

В целом, <b>VACUUM</b> обычно достаточно для поддержания эффективности работы базы данных, однако, при необходимости выполнить более глубокую очистку и компактацию таблицы, может использоваться <b>VACUUM FULL</b>. Вариант этой команды с ключевым словом <b>CONCURRENTLY</b> работает дольше, но не блокирует индекс и не мешает чтению и обновлению данных.

Вывод данных об автоочистке:
```sql
SELECT pid, backend_start, backend_type
FROM pg_stat_activity
WHERE backend_type = 'autovacuum launcher';
```


### Табличные пространства

Табличные пространства (tablespace) служат для организации физического хранения данных и определяют расположение данных в файловой системе. При инициализации кластера создаются два табичных пространства: pg_default и pg_global. Одно и то же табличное пространство может использоваться разными базами данных, а одна база данных может хранить данные в нескольких табличных пространствах.

Основные преимущества использования табличных пространств:

1. <b>Распределение данных</b>: Позволяет хранить данные на различных физических дисках или разделах дисков для более эффективного управления местом.
  
2. <b>Увеличение производительности</b>: Позволяет разместить данные на быстрых дисках или разделах, что может улучшить производительность базы данных.

3. <b>Управление местом хранения</b>: Позволяет размещать различные объекты базы данных (таблицы, индексы) в разных табличных пространствах.

В PostgreSQL можно создавать и использовать пользовательские табличные пространства для своих объектов базы данных. Например, чтобы создать табличное пространство с именем 'data_space' в каталоге '/mnt/data', можно выполнить следующий SQL запрос:

```sql
CREATE TABLESPACE data_space LOCATION '/mnt/data';
```

После создания табличного пространства, можно указывать его при создании таблиц или индексов с использованием параметра `TABLESPACE` в командах `CREATE TABLE` или `CREATE INDEX`.

Например, чтобы создать таблицу в пользовательском табличном пространстве 'data_space':
```sql
CREATE TABLE my_table 
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
) TABLESPACE data_space;
```

Таким образом, использование табличных пространств в PostgreSQL дает возможность гибко управлять распределением данных и ресурсами базы данных для оптимальной производительности и удобства администрирования.

Удалить табличное пространство если в нем есть некоторое содержимое невозможно. Для этого нужно либо удалить таблицы отдельно, либо перенести их. Чтобы перенести таблицы в табличное пространство по-умолчанию, нужно подключиться к базе данных и выполнить команду:
```sql
ALTER DATABASE db_test SET TABLESPACE pg_default;
```

Перенести все объекты в другое табличное простсранство. Перенос в другое табличное пространство - физическая операция, связанная с копированием файлов данных из каталога в каталог. На время ее выполнения доступ к перемещаемому объекту полностью блокируется:
```sql
ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE ts;
```

Затем можно удалять пустое табличное пространство:
```sql
DROP TABLESPACE test_tablespace;
```


### Резервное копирование

### Резервное копирование

Резервное копирование - это процесс создания резервных копий данных и хранения их для предотвращения потери важных данных в случае сбоя или ошибки. Резервное копирование обычно используется для восстановления данных в случае катастрофической потери данных.

Все команды выполняются от имени postgres.


### Логическая копия

<b>Логическое резервирование</b> — это набор команд SQL, восстанавливающая кластер (или базу данных, или отдельный объект) с нуля. Такая копия представляет собой, по сути, обычный текстовый файл, что дает известную гибкость (команды SQL можно выполнить на другой версии СУБД (при наличии совместимости на уровне команд) или на другой архитектуре (то есть не требуется двоичная совместимость)). Однако для большой базы этот механизм неэффективен, поскольку выполнение команд займет много времени. К тому же восстановить систему из такой резервной копии можно только на тот момент, в который она была сделана.

* <b>COPY</b> 
COPY используется для копирования данных между таблицей и файлом или между таблицей и другой таблицей. Эта команда предоставляет отличную производительность при загрузке или выгрузке большого объема данных.

Копирование данных из файла в таблицу:
```sql
COPY employees FROM '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

Копирование данных из таблицы в файл (файл должен быть создан):
```sql
COPY employees TO '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

DELIMITER ',' указывает, что данные в файле разделены запятыми, и CSV HEADER указывает, что первая строка содержит заголовки столбцов.

Параметры COPY могут включать опции формата данных (CSV, TEXT), разделитель, заголовки, игнорирование ошибок и другие. Кроме того, с помощью COPY можно копировать данные между таблицами, указывая имя целевой таблицы вместо имени файла:
```sql
COPY employees TO employees_copy;
```


* <b>pg_dump</b>
Выгружает базу данных в виде скрипта или в архивном формате. `pg_dump` — это программа для создания резервных копий базы данных PostgreSQL. Она создаёт целостные копии, даже если база параллельно используется. Программа `pg_dump` не препятствует доступу других пользователей к базе данных (ни для чтения, ни для записи).

По-умолчанию, файл с дампом будет создан в рабочем каталоге, из которого выполняется команда. Также можно указать абсолютный путь до файла вместо просто имени файла.

Выгрузка в SQL:
`pg_dump -h hostname -U dbuser -f dump.sql dbname`

Восстановление дампа:
`sudo -u postgres psql -d dbname -f dump.sql`

База данных не создастся данной командой. Базу данных нужно предварительно создать в psql от template0. Также к моменту восстановления дампа должны уже существовать все пользователи, которые имели права на объекты, иначе произойдет ошибка.

`--create`  cформировать в начале вывода команду для создания базы данных и затем подключения к ней 

`--file=файл`   отправить вывод в указанный файл

`--format=формат`   

По-умолчанию действует формат `plain`. Серьезное ограничение этого формата состоит в том, что выбирать объекты нужно в момент выгрузки. 
Формат `custom` позволяет сначала сделать полную копию, а выбирать объекты уже при загрузке. 
Формат `directory` интересен тем, что позволяет выгружать данные в несколько параллельных потоков. При этом гарантируется согласованность данных: все потоки будут использовать один и тот же снимок данных.


* <b>pg_dumpall</b>
Создает резервную копию всего кластера баз данных, включая все роли и табличные пространства. Поскольку pg_dumpall требуется доступ ко всем объектам всех БД, запускать ее следует суперпользователю или пользователю, включенному в предустановленную роль pg_read_all_data. Результатом работы pg_dumpall является скрипт для psql. Другие форматы не поддерживаются.

Дамп всего кластера:
`pg_dumpall -U postgres -f dumpall.sql`

Восстановлени полученной копии:
`sudo -u postgres psql -f dumpall.sql postgres`


Дамп со сжатием:
`pg_dump db_name | gzip > filename.gz`

`gunzip -c filename.gz | psql db_name`


`sudo -u postgres pg_dump -d test_db --table=t | psql -d test_db2`  копирование таблицы с содержимым в другую базу данных

`sudo -u postgres pg_dump -d test_db --create`  копия базы данных в виде SQL-скрипта, которая выводится в консоль (stdin)


* <b>pg_restore</b>
Утилита командной строки, предназначенная для восстановления резервной копии. Она позволяет восстановить базу данных из архивного файла, который был создан с помощью pg_dump.

Восстановление базы данных из архивного файла:
`pg_restore -d dbname filename`


Восстановление только схемы базы данных (эта команда восстановит только структуру базы данных без данных):
`pg_restore -s -d dbname filename`


Восстановление только данных без схемы (эта команда загрузит только данные в базу данных без создания таблиц и других объектов):
`pg_restore -a -d dbname filename`


Восстановление базы данных с кастомными параметрами:
`pg_restore -C -d dbname -h localhost -U username filename`

<em>Если в pg_dump, pg_dumpall и pg_restore не указывать параметр -h (хост), то подключение будет происходить по localhost.</em>

<em>После восстановления базы имеет смысл выполнить команду `ANALYZE`, которая соберет статистику.</em>


### Физическая копия

<b>Физическое резервирование</b> предполагает создание копии файловой системы (ФС). 

* Если копия создается при выключенном сервере, она называется `холодной`. Такая копия либо содержит согласованные данные (если сервер был выключен аккуратно), либо содержит все необходимые для восстановления журналы (например, если используется снимок данных  средствами операционной системы). Это упрощает восстановление, но требует останова сервера.

* Если копия создается при работающем сервере, она называется `горячей`. При горячем резервировании копия ФС будет содержать несогласованные данные. Однако механизм восстановления после сбоев можно успешно применить и к восстановлению из резервной копии. Для этого потребуются журналы предзаписи как минимум за время копирования файлов.

Для создания горячей резервной копии существует утилита `pg_basebackup`. Вначале утилита выполняет контрольную точку, затем копируется файловая система кластера. Все файлы WAL, сгенерированные сервером за время от контрольной точки до окончания копирования файлов, также копируются в резервную копию. Такая копия называется автономной, поскольку содержит в себе все необходимое для восстановления. Для восстановления достаточно развернуть резервную копию и запустить сервер. При необходимости он выполнит восстановление согласованности с помощью имеющихся файлов WAL и будет готов к работе.

Чтобы сохранить все необходимые для восстановления файлы WAL, сгенерированные сервером за время копирования файлов, утилита подключается к серверу по специальному протоколу репликации. Несмотря на название, это протокол используется не только для репликации, но и для резервного копирования. Протокол позволяет получать поток журнальных записей параллельно с копированием файлов. 

Чтобы сервер не удалил необходимые файлы WAL преждевременно, может использоваться слот репликации. Для того, чтобы подключение было возможно, необходим ряд настроек. 

* Во-первых, роль должна обладать атрибутом `REPLICATION` (или быть суперпользователем). Кроме того, этой роли должно быть выдано разрешение в конфигурационном файле <b>pg_hba.conf</b>.

* Во-вторых, параметр `max_wal_senders` должен быть установлен в достаточно большое значение. Этот параметр ограничивает число одновременно работающих процессов `wal_sender`, обслуживающих подключения по протоколу репликации.

* В-третьих, параметр `wal_level`, определяющий количество информации в журнале, должен быть установлен в значение `replica`. 


> <b><em>Принципиальная особенность протокола репликации заключается в том, что он позволяет получать поток журнальных записей параллельно с копированием файлов.</em></b>


-------------------------------------------------------------------------------------------------------

### Полезные функции PostgreSQL

##### Вывод размера (базы данных, табличных пространств)
```sql
SELECT pg_size_pretty(pg_database_size('<название_базы_данных>')),
        pg_size_pretty(pg_tablespace_size('<название_табличного пространства>'));
```

##### Вывод размера объекта базы данных (таблица, индекс и т.д.)
```sql
SELECT pg_size_pretty(pg_total_relation_size('<название_объекта>')) AS object_size;
```

##### Вывод информации о параметрах конкретной базы данных
```sql
SELECT * FROM pg_database WHERE datname = '<название_базы_данных>';
```

##### Вывод всех таблиц определенной схемы базы данных
```sql
SELECT tablename, tablespace FROM pg_tables WHERE schemaname = '<название_схемы_базы_данных>';
```

##### Вывод пути файла
```sql
SELECT pg_relation_filepath('<название файла>');
```

##### Вывод информации из файла pg_hba.conf в виде таблицы
```sql
SELECT line_number, type, database, user_name, address, auth_method
FROM pg_hba_file_rules;
```

либо из под пользователя linux:
`sudo egrep '^[^#]' /etc/postgresql/14/main/pg_hba.conf`

##### Вывод информации о процессе по его pid
```sql
SELECT query, backend_type, wait_event_type, wait_event
FROM pg_stat_activity WHERE pid = <номер процесса>;
```

##### Вывод всех незакоментированных параметров конфигурации из файла postgresql.conf
```sql
SELECT sourceline, name, setting, applied
FROM pg_file_settings
WHERE sourcefile LIKE '/etc/postgresql/13/main/postgresql.conf';
```

##### Перезагрузка файла конфигурации postgresql.conf без остановки сервера базы данных:
```sql
SELECT pg_reload_conf();
```

##### Просмотр паролей ролей в базе данных
Пароли хранятся как значение хеш-функции, не допускающее расшифровки. Сервер всегда сравнивает между собой зашифрованные значения — введенный пароль и значение из pg_authid.
```sql
SELECT rolname, rolpassword FROM pg_authid;
```

##### Поиск таблиц к базе данных, содержащих определенную колонку
```sql
SELECT table_schema, table_name
FROM information_schema.columns
WHERE column_name = '<название таблицы>'
ORDER BY table_schema, table_name;
```