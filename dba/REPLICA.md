# Репликация кластера баз данных

Репликация - это процесс создания и поддержания копии базы данных (мастер-базы) на другом сервере (реплике). Репликация позволяет распределить нагрузку на несколько серверов, обеспечить отказоустойчивость и увеличить производительность системы. Репликация может быть асинхронной или синхронной, в зависимости от того, как быстро изменения на мастер-базе должны быть переданы на реплику.


### Резервное копирование

Резервное копирование - это процесс создания резервных копий данных и хранения их для предотвращения потери важных данных в случае сбоя или ошибки. Резервное копирование обычно используется для восстановления данных в случае катастрофической потери данных.

Все команды выполняются от имени postgres.


### Логическая копия

<b>Логическое резервирование</b> — это набор команд SQL, восстанавливающая кластер (или базу данных, или отдельный объект) с нуля. Такая копия представляет собой, по сути, обычный текстовый файл, что дает известную гибкость (команды SQL можно выполнить на другой версии СУБД (при наличии совместимости на уровне команд) или на другой архитектуре (то есть не требуется двоичная совместимость)). Однако для большой базы этот механизм неэффективен, поскольку выполнение команд займет много времени. К тому же восстановить систему из такой резервной копии можно только на тот момент, в который она была сделана.

* <b>COPY</b> 
COPY используется для копирования данных между таблицей и файлом или между таблицей и другой таблицей. Эта команда предоставляет отличную производительность при загрузке или выгрузке большого объема данных.

Копирование данных из файла в таблицу:
```sql
COPY employees FROM '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

Копирование данных из таблицы в файл (файл должен быть создан):
```sql
COPY employees TO '/path/to/employees.csv' DELIMITER ',' CSV HEADER;
```

DELIMITER ',' указывает, что данные в файле разделены запятыми, и CSV HEADER указывает, что первая строка содержит заголовки столбцов.

Параметры COPY могут включать опции формата данных (CSV, TEXT), разделитель, заголовки, игнорирование ошибок и другие. Кроме того, с помощью COPY можно копировать данные между таблицами, указывая имя целевой таблицы вместо имени файла:
```sql
COPY employees TO employees_copy;
```


* <b>pg_dump</b>
Выгружает базу данных в виде скрипта или в архивном формате. `pg_dump` — это программа для создания резервных копий базы данных PostgreSQL. Она создаёт целостные копии, даже если база параллельно используется. Программа `pg_dump` не препятствует доступу других пользователей к базе данных (ни для чтения, ни для записи).

По-умолчанию, файл с дампом будет создан в рабочем каталоге, из которого выполняется команда. Также можно указать абсолютный путь до файла вместо просто имени файла.

Выгрузка в SQL:
`pg_dump -h hostname -U dbuser -f dump.sql dbname`

Восстановление дампа:
`sudo -u postgres psql -d dbname -f dump.sql`

База данных не создастся данной командой. Базу данных нужно предварительно создать в psql от template0. Также к моменту восстановления дампа должны уже существовать все пользователи, которые имели права на объекты, иначе произойдет ошибка.

`--create`  cформировать в начале вывода команду для создания базы данных и затем подключения к ней 

`--file=файл`   отправить вывод в указанный файл

`--format=формат`   

По-умолчанию действует формат `plain`. Серьезное ограничение этого формата состоит в том, что выбирать объекты нужно в момент выгрузки. 
Формат `custom` позволяет сначала сделать полную копию, а выбирать объекты уже при загрузке. 
Формат `directory` интересен тем, что позволяет выгружать данные в несколько параллельных потоков. При этом гарантируется согласованность данных: все потоки будут использовать один и тот же снимок данных.


* <b>pg_dumpall</b>
Создает резервную копию всего кластера баз данных, включая все роли и табличные пространства. Поскольку pg_dumpall требуется доступ ко всем объектам всех БД, запускать ее следует суперпользователю или пользователю, включенному в предустановленную роль pg_read_all_data. Результатом работы pg_dumpall является скрипт для psql. Другие форматы не поддерживаются.

Дамп всего кластера:
`pg_dumpall -U postgres -f dumpall.sql`

Восстановлени полученной копии:
`sudo -u postgres psql -f dumpall.sql postgres`


Дамп со сжатием:
`pg_dump db_name | gzip > filename.gz`

`gunzip -c filename.gz | psql db_name`


`sudo -u postgres pg_dump -d test_db --table=t | psql -d test_db2`  копирование таблицы с содержимым в другую базу данных

`sudo -u postgres pg_dump -d test_db --create`  копия базы данных в виде SQL-скрипта, которая выводится в консоль (stdin)


* <b>pg_restore</b>
Утилита командной строки, предназначенная для восстановления резервной копии. Она позволяет восстановить базу данных из архивного файла, который был создан с помощью pg_dump.

Восстановление базы данных из архивного файла:
`pg_restore -d dbname filename`


Восстановление только схемы базы данных (эта команда восстановит только структуру базы данных без данных):
`pg_restore -s -d dbname filename`


Восстановление только данных без схемы (эта команда загрузит только данные в базу данных без создания таблиц и других объектов):
`pg_restore -a -d dbname filename`


Восстановление базы данных с кастомными параметрами:
`pg_restore -C -d dbname -h localhost -U username filename`

<em>Если в pg_dump, pg_dumpall и pg_restore не указывать параметр -h (хост), то подключение будет происходить по localhost.</em>

<em>После восстановления базы имеет смысл выполнить команду `ANALYZE`, которая соберет статистику.</em>


### Физическая копия

<b>Физическое резервирование</b> предполагает создание копии файловой системы (ФС). 

* Если копия создается при выключенном сервере, она называется `холодной`. Такая копия либо содержит согласованные данные (если сервер был выключен аккуратно), либо содержит все необходимые для восстановления журналы (например, если используется снимок данных  средствами операционной системы). Это упрощает восстановление, но требует останова сервера.

* Если копия создается при работающем сервере, она называется `горячей`. При горячем резервировании копия ФС будет содержать несогласованные данные. Однако механизм восстановления после сбоев можно успешно применить и к восстановлению из резервной копии. Для этого потребуются журналы предзаписи как минимум за время копирования файлов.

Для создания горячей резервной копии существует утилита `pg_basebackup`. Вначале утилита выполняет контрольную точку, затем копируется файловая система кластера. Все файлы WAL, сгенерированные сервером за время от контрольной точки до окончания копирования файлов, также копируются в резервную копию. Такая копия называется автономной, поскольку содержит в себе все необходимое для восстановления. Для восстановления достаточно развернуть резервную копию и запустить сервер. При необходимости он выполнит восстановление согласованности с помощью имеющихся файлов WAL и будет готов к работе.

Чтобы сохранить все необходимые для восстановления файлы WAL, сгенерированные сервером за время копирования файлов, утилита подключается к серверу по специальному протоколу репликации. Несмотря на название, это протокол используется не только для репликации, но и для резервного копирования. Протокол позволяет получать поток журнальных записей параллельно с копированием файлов. 

Чтобы сервер не удалил необходимые файлы WAL преждевременно, может использоваться слот репликации. Для того, чтобы подключение было возможно, необходим ряд настроек. 

* Во-первых, роль должна обладать атрибутом `REPLICATION` (или быть суперпользователем). Кроме того, этой роли должно быть выдано разрешение в конфигурационном файле <b>pg_hba.conf</b>.

* Во-вторых, параметр `max_wal_senders` должен быть установлен в достаточно большое значение. Этот параметр ограничивает число одновременно работающих процессов `wal_sender`, обслуживающих подключения по протоколу репликации.

* В-третьих, параметр `wal_level`, определяющий количество информации в журнале, должен быть установлен в значение `replica`. 


> <b><em>Принципиальная особенность протокола репликации заключается в том, что он позволяет получать поток журнальных записей параллельно с копированием файлов.</em></b>


### Физическая репликация

Физическая репликация - это процесс создания копии базы данных (мастер-базы данных) на другом сервере (реплика). Эта копия является точной физической копией оригинальной базы данных и включает в себя все данные, таблицы, индексы и другие объекты.

Физическая репликация может быть использована для повышения отказоустойчивости системы, увеличения производительности путем балансировки нагрузки между мастером и репликой, а также для обеспечения географической репликации данных для обеспечения их доступности и безопасности.

Для настройки физической репликации в PostgreSQL используются специальные механизмы, такие как `streaming replication` или слоты репликации. При этом данные из мастер-сервера передаются на реплику в реальном времени, что позволяет обеспечить актуальность данных на обоих серверах.

Механизм репликации состоит в том, что один сервер передает журнальные записи на другой сервер, и тот их проигрывает — как при восстановлении после сбоя. Поскольку журнал общий для всего кластера, то и реплицировать можно только весь кластер целиком.

<em>Поскольку на реплику попадает только та информация, которая содержится в журнале, в журнал должны записываться все необходимые данные. Объем информации, попадающий в журнал, регулируется параметром `wal_level`.</em>

Алгоритм проведения репликации кластера:
1. Проверка параметров
2. Создание директории для нового кластера
3. Инициализация нового кластера
4. Остановка сервера нового кластера, очистка каталога
5. Создание резервной копии (активация pg_basebackup)
6. Запуск нового кластера
7. Проверка состояния


#### Процедура репликации

Проверка, что включен параметр `replica` и сколько может быть включено процессов одновременно:
```sql
SELECT name, setting 
FROM pg_settings 
WHERE name IN ('wal_level', 'max_val_senders');
```

Проверка, включено ли разрешение на подключение по протоколу репликации:
```sql
SELECT type, user_name, address, auth_method FROM pg_hba_file_rules
WHERE database = ARRAY['replication'];
```

Далее нужно создать директорию для нового кластера:
`sudo mkdir /var/lib/postgresql/14/replica`

Инициализировать новый кластер:
`initdb --username=postgres --pwprompt -E UTF8 /var/lib/postgresql/14/replica`      --pwprompt указывает initdb запросить пароль, который будет назначен суперпользователю базы данных. Это не важно, если не планируется использовать аутентификацию по паролю. В ином случае этот режим аутентификации оказывается неприменимым, пока пароль не задан.

Остановить его, если сервер работает:
`sudo pg_ctlcluster 14 replica stop`

Предварительно очистить каталог для кластера:
`sudo rm -rf /var/lib/postgresql/14/replica/*`

Создание резервной копии кластера (-R сформирует необходимые для репликации конфигурационные параметры). Ключ -R создаст указание серверу перейти в режим постоянного восстановления, а также поместит в файл postgresql.auto.conf настройки для подключения к основному серверу.
`pg_basebackup --pgdata=/var/lib/postgresql/14/replica/* -R`

Предоставление пользователю роли REPLICATION:
```sql
ALTER ROLE user_name REPLICATION;
```

Назначение postgres владельцем файлов каталога кластера:
`sudo chown -R postgres:postgres /var/lib/postgresql/14/replica`

Проверка содержимого каталога нового кластера:
`sudo ls -l /var/lib/postgresql/14/replica`

Проверка, что необходимый кластер, куда будет создана реплика, остановлен (down):
`sudo pg_lsclusters`

Запустить новый кластер:
`sudo pg_ctlcluster 14 replica start`

Посмотреть состояние реприкации:
```sql
SELECT * FROM pg_stat_replication \gx
```

Подключение к кластеру replica:
`psql -p 5433 -d namedb`


При использовании репликации кластера 
<b>ДОПУСКАЕТСЯ</b>:
* Запросы на чтение данных (SELECT, COPY TO, курсоры)
* Установка параметров сервера (SET, RESET)
* Управление транзакциями (BEGIN, COMMIT, ROLLBACK...)
* Создание резервной копии (pg_basebackup)

<b>НЕ ДОПУСКАЕТСЯ</b>:
* Любые изменения (INSERT, UPDATE, DELETE, TRUNCATE, nextval...)
* Блокировки, предполагающие изменение (SELECT FOR UPDATE...)
* Команды DDL (CREATE, DROP...), в т. ч. создание временных таблиц
* Команды сопровождения (VACUUM, ANALYZE, REINDEX...)
* Управление доступом (GRANT, REVOKE...)
* Не срабатывают триггеры и рекомендательные блокировки


### Восстановление

При восстановлении базовая резервная копия, включающая необходимые файлы WAL, разворачивается на другом сервере. 

<b>Процедура восстановления выполняется следующим образом:</b>
На другом (или на том же) сервере разворачивается базовая резервная копия и создается файл `recovery.signal`. Сервер запускается и начинает читать сегменты WAL из архива, используя `restore_command`, и применять их.

Резервный сервер применяет все доступные записи WAL, читая сегменты из каталога pg_wal, тем самым доводя состояние баз данных до актуального. Максимально возможная потеря - незаполненный сегмент WAL, не попавший в архив, если его по каким-то причинам невозможно скопировать. По-умолчанию применяются все доступные журнальные записи, а указание целевой точки восстановления позволяет остановить их применение в желаемый момент.

После этого резервный сервер переходит в обычный режим работы: принимает запросы, записывает сегменты WAL в архив и так далее, выступая в качестве нового полноценного основного сервера.Если развернутый сервер предполагается использовать вместо основного, то его имеет смысл располагать на таком же или, по крайней мере, сравнимом по характеристикам аппаратуры сервере, чтобы избежать снижения производительности


* <b>pg_receivewal</b> 
Утилита предназначена для записи сегментов в архив по протоколу потоковой репликации. Обычно она запускается на отдельном "архивном" сервере и подключается к мастеру с параметрами, указанными в ключах. Утилита может (и должна) использовать слот репликации, чтобы гарантированно не потерять записи. Утилита формирует файлы аналогично тому, как это делает сервер, и записывает их в указанный каталог. Еще не заполненные сегменты записываются с префиксом `.partial`. При переходе на новый сервер утилиту требуется остановить и запустить заново с соответствующими параметрами.

Утилита `pg_receivewal` подключается к серверу по протоколу потоковой репликации. Подключение обрабатывается отдельным процессом `wal sender` (это необходимо учесть при установке параметра max_wal_senders). Утилита записывает данные, не дожидаясь получения всего сегмента.


#### Потоковый архив

Создание кластера для архивации WAL:
`mkdir /var/lib/postgresql/archive`

Создание слота:
`pg_receivewal --create-slot --slot=archive`

Запуск утилиты в фоновом режиме (запустить в отдельном окне или вставить в конце командной строки символ &):
`pg_receivewal -D /var/lib/postgresql/archive --slot=archive`


#### Базовая резервная копия 

Автономная резервная копия кластера main:
`pg_basebackup --wal-method=none --pgdata=/home/fueros/basebackup`


### Логическая репликация

Логическая репликация - это метод репликации данных, при котором копирование данных из одной базы данных в другую осуществляется на уровне логических изменений данных (т.е. INSERT, UPDATE, DELETE). Это означает, что не просто копируются изменения на уровне блоков данных, как при физической репликации, а передаются только сами операции над данными.

Этот метод репликации позволяет более гибко управлять данными на целевом сервере, так как можно применять различные фильтры и трансформации данных перед их записью. Кроме того, логическая репликация может быть более эффективной в случае работы с большими объемами данных, так как не требуется пересылать полные копии блоков данных, а только изменения.

При физической репликации только один сервер (мастер) выполняет изменения и генерирует журнальные записи. Остальные серверы (реплики) только читают журнальные записи мастера и применяют их.При логической репликации все серверы работают в обычном режиме, могут изменять данные и генерировать собственные журнальные записи. Один сервер может публиковать свои изменения, а другие — подписываться на них. При этом один и тот же сервер может как публиковать изменения, так и подписываться на другие. Это позволяет организовать произвольные потоки данных между серверами. Для логической репликации не нужна двоичная совместимость, реплика должна лишь понимать протокол репликации.


Включение логической репликации
`ALTER SYSTEM SET wal_level = logical;`

Создание публикации с привязкой на реплицируемую таблицу
```sql
CREATE PUBLICATION test_publication FOR TABLE test_table;
```

Создание подписки на таблицу 
```sql
CREATE SUBSCRIPTION test_subscription
CONNECTION 'host=localhost port=5432 user=postgres password=postgres dbname=dbtest'
PUBLICATION test_publication;
```

При создании подписки все данные из таблицы test были переданы на сервер-подписчик. Если это не требуется, то к команду `CREATE SUBSCRIPTION` добавляется строка 
```sql
WITH (copy_data = false)
```

Сервер-подписчик тоже может изменять данные в таблице (но эти изменения не будут реплицированы на публикующий сервер).

Не реплицируются 
* команды DDL
<em>все изменения схемы данных надо переносить вручную</em>
* значения последовательностей 
<em>если сервер-подписчик добавляет строки в таблицу с суррогатным уникальным ключом, для которой настроена репликация, возможны конфликты. Конфликтов можно избежать, выделяя двум серверам разные диапазоны значений последовательностей, или используя вместо них универсальные уникальные идентификаторы (UUID)</em>
* большие объекты (lo)
* изменения материализованных представлений, сторонних таблиц, секционированных таблиц

Могут вызвать проблемы 
* массовые изменения данных
* изменения, сделанные долгими транзакциями 

Не поддерживаются 
* автоматическое разрешение конфликтов
* двунаправленная репликация одной и той же таблицы