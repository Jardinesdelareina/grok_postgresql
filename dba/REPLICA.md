# Репликация кластера баз данных

Репликация - это процесс создания и поддержания копии базы данных (мастер-базы) на другом сервере (реплика). Репликация позволяет распределить нагрузку на несколько серверов, обеспечить отказоустойчивость и увеличить производительность системы. Репликация может быть асинхронной или синхронной, в зависимости от того, как быстро изменения на мастер-базе должны быть переданы на реплику.


### Физическая репликация

Физическая репликация - это процесс создания копии базы данных (мастер-базы данных) на другом сервере (реплика). Эта копия является точной физической копией оригинальной базы данных и включает в себя все данные, таблицы, индексы и другие объекты.

Физическая репликация может быть использована для повышения отказоустойчивости системы, увеличения производительности путем балансировки нагрузки между мастером и репликой, а также для обеспечения географической репликации данных для обеспечения их доступности и безопасности.

Для настройки физической репликации в PostgreSQL используются специальные механизмы, такие как `streaming replication` или слоты репликации. При этом данные из мастер-сервера передаются на реплику в реальном времени, что позволяет обеспечить актуальность данных на обоих серверах.

Механизм репликации состоит в том, что один сервер передает журнальные записи на другой сервер, и тот их проигрывает — как при восстановлении после сбоя. Поскольку журнал общий для всего кластера, то и реплицировать можно только весь кластер целиком.

<em>Поскольку на реплику попадает только та информация, которая содержится в журнале, в журнал должны записываться все необходимые данные.Объем информации, попадающий в журнал, регулируется параметром `wal_level`.</em>

Алгоритм проведения репликации кластера:
1. Проверка параметров
2. Создание директории для нового кластера
3. Инициализация нового кластера
4. Остановка сервера нового кластера, очистка каталога
5. Создание резервной копии (активация pg_basebackup)
6. Запуск нового кластера
7. Проверка состояния



Проверка, что включен параметр `replica` и сколько может быть включено процессов одновременно
```sql
SELECT name, setting 
FROM pg_settings 
WHERE name IN ('wal_level', 'max_val_senders');
```


Проверка, включено ли разрешение на подключение по протоколу репликации
```sql
SELECT type, user_name, address, auth_method FROM pg_hba_file_rules
WHERE database = ARRAY['replication'];
```

Далее нужно создать директорию для нового кластера
`sudo mkdir /var/lib/postgresql/14/replica`


Инициализировать новый кластер
`initdb --username=postgres --pwprompt -E UTF8 /var/lib/postgresql/14/replica`      --pwprompt указывает initdb запросить пароль, который будет назначен суперпользователю базы данных. Это не важно, если не планируется использовать аутентификацию по паролю. В ином случае этот режим аутентификации оказывается неприменимым, пока пароль не задан


Остановить его, если сервер работает
`sudo pg_ctlcluster 14 replica stop`


Предварительно очистить каталог для кластера:
`sudo rm -rf /var/lib/postgresql/14/replica/*`


Создание резервной копии кластера (-R сформирует необходимые для репликации конфигурационные параметры). Ключ -R создаст указание серверу перейти в режим постоянного восстановления, а также поместит в файл postgresql.auto.conf настройки для подключения к основному серверу
`pg_basebackup --pgdata=/var/lib/postgresql/14/replica/* -R`


Предоставление пользователю роли REPLICATION
```sql
ALTER ROLE user_name REPLICATION;


Назначение postgres владельцем файлов каталога кластера
`sudo chown -R postgres:postgres /var/lib/postgresql/14/replica`


Проверка, что необходимый кластер, куда будет создана реплика, остановлен (down)
`sudo pg_lsclusters`


Запустить новый кластер и остановить его, если сервер работает
`sudo pg_ctlcluster 12 replica start`


Посмотреть состояние реприкации
```sql
SELECT * FROM pg_stat_replication \gx
```


При использовании репликации кластера 
<b>ДОПУСКАЕТСЯ</b>:
* Запросы на чтение данных (SELECT, COPY TO, курсоры)
* Установка параметров сервера (SET, RESET)
* Управление транзакциями (BEGIN, COMMIT, ROLLBACK...)
* Создание резервной копии (pg_basebackup)

<b>НЕ ДОПУСКАЕТСЯ</b>:
* Любые изменения (INSERT, UPDATE, DELETE, TRUNCATE, nextval...)
* Блокировки, предполагающие изменение (SELECT FOR UPDATE...)
* Команды DDL (CREATE, DROP...), в т. ч. создание временных таблиц
* Команды сопровождения (VACUUM, ANALYZE, REINDEX...)
* Управление доступом (GRANT, REVOKE...)
* Не срабатывают триггеры и рекомендательные блокировки


### Логическая репликация

Логическая репликация - это метод репликации данных, при котором копирование данных из одной базы данных в другую осуществляется на уровне логических изменений данных (т.е. INSERT, UPDATE, DELETE). Это означает, что не просто копируются изменения на уровне блоков данных, как при физической репликации, а передаются только сами операции над данными.

Этот метод репликации позволяет более гибко управлять данными на целевом сервере, так как можно применять различные фильтры и трансформации данных перед их записью. Кроме того, логическая репликация может быть более эффективной в случае работы с большими объемами данных, так как не требуется пересылать полные копии блоков данных, а только изменения.

При физической репликации только один сервер (мастер) выполняет изменения и генерирует журнальные записи. Остальные серверы (реплики) только читают журнальные записи мастера и применяют их.При логической репликации все серверы работают в обычном режиме, могут изменять данные и генерировать собственные журнальные записи. Один сервер может публиковать свои изменения, а другие — подписываться на них. При этом один и тот же сервер может как публиковать изменения, так и подписываться на другие. Это позволяет организовать произвольные потоки данных между серверами. Для логической репликации не нужна двоичная совместимость, реплика должна лишь понимать протокол репликации.


Включение логической репликации
`ALTER SYSTEM SET wal_level = logical;`


Создание публикации с привязкой на реплицируемую таблицу
```sql
CREATE PUBLICATION test_publication FOR TABLE test_table;
```

Создание подписки на таблицу 
```sql
CREATE SUBSCRIPTION test_subscription
CONNECTION 'host=localhost port=5432 user=postgres password=postgres dbname=dbtest'
PUBLICATION test_publication;
```

При создании подписки все данные из таблицы test были переданы на сервер-подписчик. Если это не требуется, то к команду `CREATE SUBSCRIPTION` добавляется строка 
```sql
WITH (copy_data = false)
```

Сервер-подписчик тоже может изменять данные в таблице (но эти изменения не будут реплицированы на публикующий сервер).

Не реплицируются 
* команды DDL
<em>все изменения схемы данных надо переносить вручную</em>
* значения последовательностей 
<em>если сервер-подписчик добавляет строки в таблицу с суррогатным уникальным ключом, для которой настроена репликация, возможны конфликты. Конфликтов можно избежать, выделяя двум серверам разные диапазоны значений последовательностей, или используя вместо них универсальные уникальные идентификаторы (UUID)</em>
* большие объекты (lo)
* изменения материализованных представлений, сторонних таблиц, секционированных таблиц

Могут вызвать проблемы 
* массовые изменения данных
* изменения, сделанные долгими транзакциями 

Не поддерживаются 
* автоматическое разрешение конфликтов
* двунаправленная репликация одной и той же таблицы