----------------------------------
# Конфигурационный файл PostgreSQL
----------------------------------

Этот файл состоит из строк вида `имя = значение`.

Знак `=` не является обязательным. Можно использовать пробелы. Комментарии вводятся с помощью
`#` в любом месте строки. Полный список названий параметров и разрешенных
значения можно найти в документации PostgreSQL.

Закомментированные настройки, показанные в этом файле, представляют собой значения по-умолчанию.
Повторного комментирования параметра НЕДОСТАТОЧНО, чтобы вернуть его к значению по-умолчанию, нужно перезагрузить сервер.

Этот файл читается при запуске сервера и когда сервер получает SIGHUP.
сигнал. Если вы редактируете файл в работающей системе, вам необходимо ПОДПИСАТЬСЯ.
сервер, чтобы изменения вступили в силу, запустите "pg_ctl reload" или выполните
`SELECT pg_reload_conf()`. Некоторые параметры, отмеченные ниже, требуют выключения и перезапуска сервера, чтобы изменения вступили в силу.

Любой параметр также может быть передан серверу в качестве параметра командной строки, например:
`postgres -c log_connections=on`. Некоторые параметры можно изменить во время выполнения.
с помощью SQL-команды SET.

Блоки памяти:  
* B  = байты
* kB = килобайты
* MB = мегабайты
* GB = гигабайты
* TB = терабайты


Единицы времени:
* us = микросекунды
* ms = милисекунды
* s = секунды
* min = минуты
* h = часы
* d = дни


-----------------------
### РАСПОЛОЖЕНИЕ ФАЙЛОВ
-----------------------

Значения этих переменных по-умолчанию задаются из командной строки -D 
или из переменной среды PGDATA, представленной здесь как ConfigDir.

`data_directory = '/var/lib/postgresql/14/main'`	определяет путь к директории, в которой хранятся данные PostgreSQL. Здесь указывается полный путь к каталогу, который содержит файлы баз данных, журналы операций с базами данных и другие связанные файлы.

`hba_file = '/etc/postgresql/14/main/pg_hba.conf'`	задает путь к файлу pg_hba.conf. Файл pg_hba.conf содержит правила аутентификации для подключения к PostgreSQL серверу. В этом файле определяются разрешенные методы аутентификации, разрешенные хосты и пользователи для подключения, а также настройки SSL-шифрования.

`ident_file = '/etc/postgresql/14/main/pg_ident.conf'`	указывает путь к файлу `pg_ident.conf`. Файл `pg_ident.conf` используется для настройки идентификации пользователей в системе PostgreSQL. В этом файле указываются соответствия между операционными системными пользователями и их именами в базе данных PostgreSQL.

`external_pid_file = '/var/run/postgresql/14-main.pid'`	указывает путь к файлу, в котором будет сохранен идентификатор процесса (PID) основного процесса PostgreSQL. Этот файл используется для контроля и мониторинга процесса PostgreSQL и может использоваться другими инструментами для управления сервером PostgreSQL. Если external_pid_file не задан явно, дополнительный файл PID не записывается.


--------------------------------
### ПОДКЛЮЧЕНИЯ И АУТЕНТИФИКАЦИЯ
--------------------------------

##### Настройки подключения

`#listen_addresses = 'localhost'`	используется для указания сетевых интерфейсов, на которых PostgreSQL будет прослушивать входящие соединения.

По-умолчанию для параметра `listen_addresses` установлено значение `localhost`, что означает, что PostgreSQL прослушивает соединения только на локальном компьютере. Если вы хотите разрешить подключения с удаленных хостов, вы можете установить для параметра `listen_addresses` IP-адрес сетевого интерфейса, на котором вы хотите принимать соединения, или вы можете установить для него значение «*», чтобы прослушивать все доступные сетевые интерфейсы.

`port = 5432`	задает порт, на котором будет слушать сервер базы данных PostgreSQL. Значение `5432` является портом по-умолчанию для PostgreSQL. Когда клиентское приложение подключается к серверу, оно указывает порт, чтобы установить соединение с базой данных. 

`max_connections = 100`	устанавливает максимальное количество одновременных соединений с сервером базы данных PostgreSQL. Когда количество клиентов превышает это значение, новые соединения будут отклонены до тех пор, пока количество активных соединений не уменьшится.

`#superuser_reserved_connections = 3`	указывает количество подключений, зарезервированных для суперпользователей, которые все еще могут подключаться к серверу PostgreSQL даже при достижении максимального количества подключений. Это гарантирует, что несколько соединений всегда доступны для административных целей, что позволяет суперпользователям диагностировать и решать проблемы, когда сервер находится под большой нагрузкой.

`unix_socket_directories = '/var/run/postgresql'`	указывает директории, в которых сервер PostgreSQL будет искать UNIX-сокеты для подключения. UNIX-сокеты - это способ коммуникации между клиентом и сервером на локальной машине, который обеспечивает более эффективное взаимодействие, чем используемые TCP/IP соединения. Указание одной или нескольких директорий позволяет серверу приема подключений прослушивать сразу несколько мест, где могут находиться сокеты клиентов.
					
`#unix_socket_group = ''`	указывает группу, для которой будет доступно соединение через UNIX-сокет. 

В системах Unix, соединения через UNIX-сокеты обычно основаны на правах доступа к файлам и группах. Когда PostgreSQL создает UNIX-сокет для соединения клиента с сервером, он устанавливает группу сокета в указанное значение `unix_socket_group`. Это гарантирует, что только пользователи, принадлежащие к указанной группе, имеют доступ к этому сокету и могут подключаться к серверу.

Если параметр `unix_socket_group` установлен в пустую строку (`''`), то для сокета не устанавливается группа, и любой пользователь может подключиться к серверу через UNIX-сокет.

`#unix_socket_permissions = 0777`	определяет права доступа к файловому сокету Unix, который используется для локального подключения к серверу PostgreSQL. Значение `0777` указывает, что все пользователи, включая владельца, группу и остальных пользователей, имеют полный доступ на чтение, запись и выполнение файлового сокета. Это позволяет любым пользователям на хосте подключаться к серверу PostgreSQL через локальный сокет и выполнять операции базы данных.

`#bonjour = off`	относится к сетевому протоколу Bonjour. Bonjour – это технология, разработанная Apple, которая позволяет компьютерам и устройствам в сети автоматически находить друг друга и устанавливать соединение без необходимости настройки IP-адресов или DNS-серверов.

Когда параметр bonjour установлен в "off", PostgreSQL не будет рассылать свои сетевые анонсы или откликаться на запросы Bonjour других устройств в локальной сети. Это может быть полезно в ситуациях, когда вы не хотите, чтобы PostgreSQL обнаруживался и доступался из других устройств в сети.

Этот параметр может быть полезным при обеспечении безопасности или когда вы хотите ограничить доступ к вашей базе данных только для определенных машин или приложений.

`#bonjour_name = ''`	имя компьютера в протоколе Bonjour по-умолчанию.


##### - TCP Настройки -

Данные настройки относятся к TCP keepalive-механизму, который активируется для поддержания активного соединения между клиентом и сервером базы данных PostgreSQL.

`#tcp_keepalives_idle = 0`	задает время в секундах без активности, после которого TCP-соединение считается неактивным и отправляются keepalive-сообщения. Значение 0 отключает использование keepalive-сообщений.

`#tcp_keepalives_interval = 0`	указывает интервал между последовательными keepalive-сообщениями (в секундах). Также принимается значение 0 для отключения опции. Проверка наличия TCP-соединений включает отправку "keepalive" пакетов между клиентом и сервером с определенным интервалом. Это позволяет обнаруживать разорванные соединения или неактивные клиенты и реагировать на них соответствующим образом.

`#tcp_keepalives_count = 0`	определяет количество keepalive-сообщений, которые необходимо отправить, прежде чем соединение будет помечено как разорванное. Если значение равно 0, то количество keepalive-сообщений не ограничено.

`#tcp_user_timeout = 0`	определяет время в миллисекундах, после которого сервер обрывает соединение TCP, если клиент не ответил. Значение 0 указывает использовать системную настройку по-умолчанию.

`#client_connection_check_interval = 0`	определяет интервал времени (в секундах), через который сервер будет проверять активность клиентских соединений. Если клиент не отправляет или не получает данные в течение указанного интервала, сервер может считать соединение неактивным и закрыть его. Значение 0 означает отключение этой проверки.


###### - Аутентификация -

`#authentication_timeout = 1min`	(1s-600s) указывает время ожидания сервера для аутентификации пользователя в минутах. Если сервер не получает ответ от клиента в течение указанного времени, то соединение будет разорвано.

`#password_encryption = scram-sha-256`	(scram-sha-256 или md5) задает алгоритм шифрования паролей пользователей. Значение "scram-sha-256" указывает на использование механизма аутентификации SCRAM-SHA-256, который обеспечивает более безопасное хранение паролей с использованием соли и итераций.

`#db_user_namespace = off`	определяет, будут ли имена пользователей связаны с именами баз данных. Если значение "off", то имена пользователей могут быть одинаковыми в разных базах данных. Если значение "on", то имена пользователей должны быть уникальными в пределах каждой базы данных.


<b>GSSAPI/Kerberos</b>
Начиная с версии 12, PostgreSQL поддерживает авторизацию с использованием GSSAPI/Kerberos. Эта функциональность позволяет клиентам аутентифицироваться на сервере PostgreSQL с использованием Kerberos-токенов, удобно интегрируясь с существующей инфраструктурой безопасности.

`#krb_server_keyfile = 'FILE:${sysconfdir}/krb5.keytab'`	определяет местоположение ключевого файла сервера Kerberos, который содержит необходимые ключи шифрования для аутентификации.

После включения авторизации GSSAPI/Kerberos в файле postgresql.conf, вы также должны настроить файл pg_hba.conf для определения правил аутентификации с использованием GSSAPI/Kerberos. Например:

```
# IPv4 local connections:
host    all             all             127.0.0.1/32             gss     include_realm=0
```

Здесь `gss` - это специальный тип аутентификации, позволяющий клиентам использовать GSSAPI/Kerberos для аутентификации. Вы можете определить различные правила для разных хостов, пользователей и баз данных.

`#krb_caseins_users = off`	используется для указания того, должен ли Kerberos учитывать регистр символов при аутентификации пользователей.

Когда этот параметр установлен в значение off, Kerberos будет регистронезависимым при поиске пользователей для аутентификации. Это означает, что пользователь с именем "John" сможет аутентифицироваться как "john" или "JOHN". Если параметр установлен в значение on, то регистр символов будет учитываться при аутентификации, и пользователь "John" не сможет использовать "john" или "JOHN" для входа.


##### - SSL -

Настройка SSL (Secure Sockets Layer) позволяет обеспечить защищенное соединение между клиентами и сервером PostgreSQL.

`ssl = on`	включение SSL.

`#ssl_ca_file = ''`	путь к файлу корневого сертификата (CA) для проверки цепочки сертификатов сервера.

`ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'`	путь к сертификату сервера.

`#ssl_crl_file = ''`	путь к файлу отзыва (CRL) для проверки статуса сертификатов сервера.

`#ssl_crl_dir = ''`	каталог, в котором содержатся файлы отзыва для проверки статуса сертификатов сервера.

`ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'`	путь к приватному ключу сервера.

`#ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL'`	список шифров, поддерживаемых SSL соединением сервера с клиентом.

`#ssl_prefer_server_ciphers = on`	указывает использовать приоритет SSL шифров сервера перед клиентскими шифрами.

`#ssl_ecdh_curve = 'prime256v1'`	Указывает используемую кривую эллиптической криптографии для обмена ключами ECDH.

`#ssl_min_protocol_version = 'TLSv1.2'`	минимальная поддерживаемая версия протокола SSL/TLS.

`#ssl_max_protocol_version = ''`	максимальная поддерживаемая версия протокола SSL/TLS.

`#ssl_dh_params_file = ''`	путь к файлу параметров алгоритма Диффи-Хеллмана для SSL.

`#ssl_passphrase_command = ''`	команда, используемая для получения пароля приватного ключа сертификата с помощью внешней программы.

`#ssl_passphrase_command_supports_reload = off`	определяет, поддерживает ли внешняя программа команду перезагрузки или сброса пароля.


--------------------------------------
### ИСПОЛЬЗОВАНИЕ РЕСУРСОВ (кроме WAL)
--------------------------------------

##### - Память -

`shared_buffers = 128MB`	отвечает за выделение оперативной памяти для работы с общим буфером Postgres. Общий буфер используется для кэширования данных, что может повысить производительность базы данных.

`#huge_pages = try`	относится к использованию "огромных страниц" (huge pages) в операционной системе. Огромные страницы являются особенным типом памяти, который обладает некоторыми преимуществами в производительности. Однако, наличие поддержки огромных страниц и их корректная настройка зависит от операционной системы и настройки системы. Значение `try` указывает PostgreSQL попробовать использовать огромные страницы, если они доступны на системе.

`#huge_page_size = 0`	определяет размер hugepages в байтах. Значение 0 означает, что размер hugepages будет автоматически настроен на оптимальное значение операционной системы.

`#temp_buffers = 8MB`	указывает количество памяти, выделяемой для временных объектов, таких как временные таблицы или сортировочные структуры данных, в оперативной памяти. Значение 8MB указывает, что выделено 8 мегабайт оперативной памяти для временных объектов.

`#max_prepared_transactions = 0`	определяет максимальное количество предварительно подготовленных транзакций, которые могут быть активными одновременно. Значение 0 указывает, что предварительно подготовленные транзакции не включены, и PostgreSQL не будет их использовать. Не рекомендуется устанавливать значение ненулевым, если только вы активно намерены использовать подготовленные транзакции.

`#work_mem = 4MB`	определяет максимальный объем памяти, который может быть использован для операций сортировки и хеш-таблиц внутри PostgreSQL.

`#hash_mem_multiplier = 1.0`	определяет множитель, используемый для вычисления отведенной памяти для хеш-таблиц. Значение 1.0 означает, что выделенная память будет равна `work_mem`, а более высокие значения увеличивают отведенную память.

`#maintenance_work_mem = 64MB`	определяет объем памяти, который будет использован для операций обслуживания, таких как перестроение индексов или выполнение команды `VACUUM`.

`#autovacuum_work_mem = -1`	определяет объем памяти, который будет использован для операций автоматического обслуживания (автовакуумирования), если не указан явно. Значение -1 означает, что будет использовано значение `maintenance_work_mem`.

`#logical_decoding_work_mem = 64MB`	определяет объем памяти, который будет использован для операций дешифровки логического журнала при использовании логического декодирования.

`#max_stack_depth = 2MB`	определяет максимальную глубину стека для каждого запроса. Это значение должно быть достаточным для выполнения ваших запросов, но слишком большие значения могут привести к исчерпанию памяти на сервере.

`#shared_memory_type = mmap`	определяет тип разделяемой памяти, используемой PostgreSQL (mmap, sysv, windows).

`dynamic_shared_memory_type = posix`	определяет тип динамической разделяемой памяти, используемой PostgreSQL (posix, sysv, windows, mmap).

`#min_dynamic_shared_memory = 0MB`	определяет минимальный объем памяти, выделяемой для динамической разделяемой памяти. Значение 0 указывает на отсутствие минимального объема памяти.


##### - Диск -

`#temp_file_limit = -1`	устанавливает предел размера временных файлов, которые могут использоваться сервером PostgreSQL. Значение -1 означает, что предел не ограничен.


##### - Ресурсы ядра (Kernel Resources) -

`#max_files_per_process = 1000`	(минимум 64) определяет максимальное количество файлов, которые может открыть каждый процесс сервера PostgreSQL. Каждое открытое соединение с базой данных и каждая активная транзакция требуют соответствующего количества открытых файлов. 


##### - Cost-Based Vacuum Delay -

Данные настройки отвечают за контроль над задержкой и затратами, связанными с операцией VACUUM.

`#vacuum_cost_delay = 0`	(0-100 милисекунд) определяет задержку между итерациями операции VACUUM в миллисекундах. Значение 0 означает, что задержка отключена. Большее значение приведет к большей задержке между итерациями.

`#vacuum_cost_page_hit = 1`	(0-10000 credits) определяет затраты, связанные с чтением из кэша страницы.

`#vacuum_cost_page_miss = 2`	(0-10000 credits) определяет затраты, связанные с чтением страницы, отсутствующей в кэше.

`#vacuum_cost_page_dirty = 20`	(0-10000 credits) определяет затраты на запись измененной страницы.

`#vacuum_cost_limit = 200`	(1-10000 credits) пределяет пороговое значение, после которого VACUUM будет считать стоимость операции слишком высокой и прекратит выполнение.


##### - Background Writer -

Эти настройки отвечают за управление фоновым процессом, который выполняет запись данных из shared_buffers (оперативной памяти) на диск. 

`#bgwriter_delay = 200ms`	(10-10000ms) задает задержку между запусками фонового процесса записи в миллисекундах. Значение 200ms означает, что фоновый процесс будет запускаться каждые 200 миллисекунд.

`#bgwriter_lru_maxpages = 100`	указывает максимальное количество страниц, которые фоновый процесс может записать за одну итерацию. Значение 100 означает, что фоновый процесс не будет записывать более 100 страниц за раз.

`#bgwriter_lru_multiplier = 2.0`	управляет тем, как быстро фоновый процесс увеличивает количество записываемых страниц при недостаточном объеме доступной памяти. Значение 2.0 означает, что количество записываемых страниц будет удваиваться при каждой следующей итерации.

`#bgwriter_flush_after = 512kB`	указывает объем измененных данных, после которого фоновый процесс выполнит запись на диск. Значение 512kB означает, что запись будет выполняться после накопления 512 килобайт данных.


##### - Асинхронное поведение (Asynchronous Behavior) -

Настройки Asynchronous Behavior регулируют поведение и конфигурацию работы с асинхронными операциями в PostgreSQL.

`#backend_flush_after = 0`	определяет пороговое значение для сброса изменений буферизованных данных в файловую систему. Значение 0 отключает данную опцию.

`#effective_io_concurrency = 1`	(1-1000) определяет количество одновременных операций ввода-вывода, которые PostgreSQL может выполнять для одного клиента. Значение 1 означает отсутствие параллельных операций, 0 отключает предварительную выборку.

`#maintenance_io_concurrency = 10`	(1-1000) определяет количество одновременных операций ввода-вывода, которые PostgreSQL может выполнять во время процессов обслуживания и обслуживания таблиц. Значение 10 предоставляет 10 параллельных операций, 0 отключает предварительную выборку.

`#max_worker_processes = 8`	определяет максимальное количество рабочих процессов (worker processes), которые могут выполняться в PostgreSQL.

`#max_parallel_workers_per_gather = 2`	определяет максимальное количество параллельных рабочих процессов, которые могут быть запущены во время операции сбора данных (gather operation).

`#max_parallel_maintenance_workers = 2`	определяет максимальное количество параллельных рабочих процессов, которые могут использоваться в процессах обслуживания и обслуживания таблиц.

`#max_parallel_workers = 8`	определяет максимальное общее количество параллельных рабочих процессов, которые могут быть запущены одновременно.

`#parallel_leader_participation = on`	определяет, будет ли лидер (leader) параллельной операции активно участвовать в выполнении операции или будет выполнять только роль координатора.

`#old_snapshot_threshold = -1`	(1min-60d) определяет пороговое время в миллисекундах, после которого должен быть сгенерирован новый снимок для транзакций, которые дольше этого времени.


---------------------------------------------------
### ЖУРНАЛ ПРЕДВАРИТЕЛЬНОЙ ЗАПИСИ (WRITE-AHEAD LOG)
---------------------------------------------------

Настройки WRITE-AHEAD LOG отвечают за параметры журнала записи (Write-Ahead Log, WAL). Журнал записи используется для обеспечения целостности данных и восстановления после сбоев системы.

##### - Настройки -

`#wal_level = replica`	(minimal, replica, или logical) устанавливает минимальный уровень записи в журнале, необходимый для репликации. В данном случае, запись в журнал осуществляется на уровне, достаточном для репликации на другие серверы.

`#fsync = on`	указывает PostgreSQL вызывать функцию fsync() (сбросить данные на диск для безопасности при сбоях) после каждого записывания в журнал и данных, чтобы гарантировать сохранность данных даже в случае сбоя. Отключение этого параметра может привести к
невосстановимое повреждение данных.

`#synchronous_commit = on`	(off, local, remote_write, remote_apply или on) когда эта настройка включена, PostgreSQL будет дожидаться подтверждения коммита от дисковой системы, прежде чем сообщать клиентскому приложению об успешном завершении транзакции.

`#wal_sync_method = fsync`	определяет метод синхронизации записи WAL на диск. Доступные методы: open_datasync, fdatasync (по-умолчанию в Linux и FreeBSD), fsync, fsync_writethrough, open_sync.

`#full_page_writes = on`	когда эта настройка включена, PostgreSQL будет сохранять полностью изменившиеся страницы данных в журнале, а не только измененные блоки, чтобы обеспечить согласованность данных при восстановлении после сбоя.

`#wal_log_hints = off`	определяет, будут ли записываться подсказки для ускорения восстановления из журнала (WAL log hints).

`#wal_compression = off`	сжатие журнальных файлов.

`#wal_init_zero = on`	инициализация WAL-файлов нулевыми байтами.

`#wal_recycle = on`	перезапись старых WAL-файлов. 

`#wal_buffers = -1`	(минимум 32 kb) определяет количество буферов в памяти, выделенных для хранения записей WAL. Значение -1 означает автоматическое определение этого значения PostgreSQL в зависимости от общего объема доступной памяти.

`#wal_writer_delay = 200ms`	(1-10000 ms) время задержки между итерациями фонового процесса записи WAL.

`#wal_writer_flush_after = 1MB`	определяет размер внутреннего буфера записи WAL, после которого фоновый процесс записи проводит синхронизацию с диском.

`#wal_skip_threshold = 2MB`	определяет пороговое значение для перехода в состояние "skip writing" вместо записи WAL-файлов на диск.

`#commit_delay = 0`	(0-100000) задержка между коммитами в микросекундах.

`#commit_siblings = 5`	(1-1000) определяет максимальное количество транзакций, которые могут иметь одинаковый родительский ID до того, как PostgreSQL выполнит дополнительные проверки при коммите.


##### - Checkpoints -

`#checkpoint_timeout = 5min`	(30s-1d) определяет время (в минутах) между автоматическими проверками точек сохранения (checkpoints). При достижении этого времени система выполнит checkpoint.

`#checkpoint_completion_target = 0.9`	(0.0 - 1.0) определяет часть буферов, которые должны быть скопированы на диск до завершения работы checkpoint. Значение 0.9 означает, что система должна скопировать на диск 90% буферов до завершения checkpoint.

`#checkpoint_flush_after = 256kB`	определяет количество записей, которые должны быть накоплены в буфере перед их записью на диск во время checkpoint.

`#checkpoint_warning = 30s`	(0 отключает) определяет время (в секундах), после которого система выдаст предупреждение о длительности checkpoint, если он продолжается дольше этого времени.

`max_wal_size = 1GB`	определяют максимальный и минимальный размер WAL-файла (Write-Ahead Log), используемого для обеспечения целостности данных и восстановления после сбоев.

`min_wal_size = 80MB`


##### - Архивирование -

Архивирование WAL-файлов полезно для обеспечения надежности данных. При обычной работе PostgreSQL записывает изменения в WAL-файлы, а затем переносит их на диск. Архивирование WAL-файлов позволяет сохранить копию этих файлов в удаленном хранилище, что обеспечивает возможность восстановления данных в случае сбоя или потери данных на основном сервере.

`#archive_mode = off`	(off, on, или always) определяет, включено ли архивирование WAL или нет.

`#archive_command = ''`	определяет, какие файлы WAL будут архивироваться. Обычно используется для копирования WAL в удаленное хранилище. Если #archive_mode установлен на "off", эта настройка игнорируется.
				
`#archive_timeout = 0`	задает интервал времени (в секундах), через который производится проверка на наличие готовых к архивированию WAL-файлов. Если установлено значение "0", то проверка не выполняется.


##### - Восстановление архива -

Эти настройки относятся к режиму восстановления базы данных, когда используется архивирование журнала транзакций для восстановления до определенной временной точки или для восстановления на другой сервер. В обычных условиях эксплуатации эти настройки не требуются и должны быть закомментированы или иметь пустое значение.

`#restore_command = ''`	позволяет указать команду, которая будет использоваться для восстановления архивных файлов журнала транзакций в режиме восстановления. 

`#archive_cleanup_command = ''`	определяет команду, которая будет выполнять очистку устаревших архивных файлов журнала транзакций. Эта команда используется в режимах архивации и восстановления, когда PostgreSQL нуждается в удалении устаревших файлов, чтобы освободить дисковое пространство.

`#recovery_end_command = ''`	указывает команду, которая будет запущена при завершении процесса восстановления базы данных. Это позволяет выполнять некоторые дополнительные действия, связанные с завершением процесса восстановления.


##### - Цель восстановления-

Настройки, связанные с восстановлением базы данных (recovery), определяют условия и процедуры для восстановления базы данных после сбоя.

`#recovery_target = ''`	определяет цель восстановления. Может быть установлено на пустую строку (по-умолчанию), чтобы не устанавливать цель, или может содержать значение времени, идентификатора транзакции (xid) или логического смещения журнала (lsn), указывающее на конкретную точку во времени, которую нужно восстановить.

`#recovery_target_name = ''`	имя для указанной цели восстановления. Используется для идентификации целей в журнале восстановления.

`#recovery_target_time = ''`	время, к которому нужно восстановить базу данных. Указывается в формате 'YYYY-MM-DD HH:MI:SS' (например, '2021-01-01 12:00:00').

`#recovery_target_xid = ''`	идентификатор транзакции (xid), к которому нужно восстановить базу данных.

`#recovery_target_lsn = ''`	логическое смещение журнала (lsn), к которому нужно восстановить базу данных.

`#recovery_target_inclusive = on`	указывает, следует ли остановить восстановление сразу после указанной цели восстановления (on) или непосредственно перед целью восстановления (false).

`#recovery_target_timeline = 'latest'`	('current', 'latest', или timeline ID) определяет временную линию восстановления, которую нужно использовать. Использование значения 'latest' означает, что нужно использовать последнюю доступную временную линию.

`#recovery_target_action = 'pause'`	определяет действие после достижения цели восстановления. Может быть 'pause' (остановить), 'promote' (повысить) или 'shutdown' (выключить).


--------------
### РЕПЛИКАЦИЯ
--------------

##### - Отправляющие серверы (Sending Servers) - 

`#max_wal_senders = 10`	определяет максимальное число параллельных отправителей WAL (Write-Ahead Log) для асинхронной репликации.

`#max_replication_slots = 10`	Устанавливает максимальное число слотов репликации, которые могут быть созданы. Слоты репликации используются для логической репликации.

`#wal_keep_size = 0`	определяет количество данных WAL в мегабайтах, которые будут сохранены для возможного использования при восстановлении отставших реплик. Значение 0 отключает это поведение.

`#max_slot_wal_keep_size = -1`	ограничивает использование места на диске для хранения WAL в мегабайтах, связанного с определенными слотами репликации. Значение -1 отключает это поведение.

`#wal_sender_timeout = 60s`	задает время ожидания отправителя WAL (Write-Ahead Log) до отключения, если нет активности.

`#track_commit_timestamp = off`	определяет, должны ли транзакции отслеживать время отправки коммита в системе. Это может быть полезно для применения логической репликации и управления временем.


##### - Основной сервер (Primary Server) -

`#synchronous_standby_names = ''`	позволяет указать список реплик, которые должны синхронизироваться с мастером перед подтверждением транзакций. Значение по-умолчанию – пустая строка, что означает отсутствие синхронных резервных узлов.

`#vacuum_defer_cleanup_age = 0`	определяет количество транзакций, после которых очистка устаревших данных может быть отложена. Значение 0 указывает на то, что очистку следует выполнять сразу после транзакции.


##### - Резервные серверы (Standby Servers) -

`#primary_conninfo = ''`	определяет параметры соединения для потока репликации, который используется для передачи WAL-журналов между мастером и репликой.

`#primary_slot_name = ''`	указывает имя слота репликации, который должен использоваться для подключения к первичному серверу. Слот репликации может быть использован для управления поведением репликации, таким как брошенные соединения, сохранение WAL-файлов и т.д.

`#promote_trigger_file = ''`	файл, который может использоваться для управления процессом автоматического продвижения реплики в режиме горячего резервного копирования до режима главного сервера. Если файл существует, реплика будет продвинута в режим главного сервера.

`#hot_standby = on`	пределяет, допускается ли чтение с реплик (горячее резервное копирование). Если установлено в "on", реплика может служить как для чтения, так и для записи.

`#max_standby_archive_delay = 30s`	определяют максимальное время задержки для применения архивных WAL-журналов. Значение -1 допускает неопределенную задержку.

`#max_standby_streaming_delay = 30s`	определяют максимальное время задержки для применения потоковых WAL-журналов.

`#wal_receiver_create_temp_slot = off`	указывает, должен ли приемник WAL-журнала создавать временный слот репликации для подключения к первичному серверу. Он используется, когда нет явно определенного слота репликации.

`#wal_receiver_status_interval = 10s`	определяет интервал между обновлениями статуса процесса получения WAL-журналов на реплике.

`#hot_standby_feedback = off`	включает обратную связь с мастером, чтобы минимизировать задержки репликации на реплике при чтении с него.

`#wal_receiver_timeout = 60s`	определяет тайм-аут ожидания получения WAL-журналов.

`#wal_retrieve_retry_interval = 5s`	определяет интервал повторной попытки получения WAL-журналов, если произошла ошибка при получении.

`#recovery_min_apply_delay = 0`	устанавливает минимальную задержку после записи транзакции на мастере, перед ее применением на реплике. Это может использоваться для ограничения нагрузки на реплику.


##### - Подписчики (Subscribers) -

`#max_logical_replication_workers = 4`	определяет максимальное количество рабочих процессов, которые могут одновременно участвовать в логической репликации. Логическая репликация позволяет передавать изменения данных на уровне логических записей, в отличие от физической репликации, которая работает на уровне блоков данных.

`#max_sync_workers_per_subscription = 2`	определяет максимальное количество рабочих процессов, которые могут одновременно удерживать соединение с исходной базой данных для выполнения синхронной логической репликации.


------------------------
### ОПТИМИЗАЦИЯ ЗАПРОСОВ
------------------------

##### - Конфигурация метода планировщика (Planner Method Configuration) -

`#enable_async_append = on`	включает или отключает асинхронное выполнение append-операций на диске.

`#enable_bitmapscan = on`	включает или отключает использование операции Bitmap Scan, которая используется для более эффективного сканирования индексов.

`#enable_gathermerge = on`	включает или отключает использование операции Gather Merge для объединения результатов параллельного выполнения.

`#enable_hashagg = on`	включает или отключает использование операции Hash Aggregation, которая используется для агрегации данных на основе хэш-таблиц.

`#enable_hashjoin = on`	включает или отключает использование операции Hash Join, которая используется для эффективного объединения данных на основе хэш-таблиц. 

`#enable_incremental_sort = on`	включает или отключает использование инкрементальной сортировки, которая может улучшить производительность при сортировке больших объемов данных. 

`#enable_indexscan = on`	включает или отключает использование сканирования индексов. 

`#enable_indexonlyscan = on`	включает или отключает использование операции Index Only Scan, которая может использовать только индексы для выполнения запроса без доступа к таблице. 

`#enable_memoize = on`	включает или отключает использование мемоизации. Мемоизация - это техника, которая заключается в сохранении результатов выполнения функции при одинаковых входных параметрах. Это позволяет избежать повторных вычислений и улучшить производительность системы.

`#enable_material = on`	включает или отключает использование операции Materialize, которая создает временные таблицы для хранения результатов промежуточных операций. 

`#enable_mergejoin = on`	включает или отключает использование операции Merge Join, которая используется для объединения отсортированных данных из разных источников. 

`#enable_nestloop = on`	включает или отключает использование операции Nested Loop Join, которая используется для объединения данных из разных источников. 

`#enable_parallel_append = on`	включает асинхронное выполнение операции Append, которая объединяет результаты множества запросов. 

`#enable_parallel_hash = on`	включает асинхронное выполнение операции Hash для распределенного хэширования. 

`#enable_partition_pruning = on`	включает или отключает оптимизацию запросов на основе информации о разделах таблицы. 

`#enable_partitionwise_join = off`	включает или отключает выполнение партиционного объединения данных из разных разделов таблицы. 

`#enable_partitionwise_aggregate = off`	включает или отключает выполнение партиционной агрегации данных из разных разделов таблицы.

`#enable_seqscan = on`	включает или отключает использование последовательного сканирования таблицы для выполнения запросов.

`#enable_sort = on`	включает или отключает использование операции Sort, которая выполняет сортировку данных.

`#enable_tidscan = on`	включает или отключает использование операции TID Scan, которая позволяет выполнить поиск по физическим адресам строк в таблице. По-умолчанию включено.


##### - Константы планировщика (Planner Cost Constants) -

`#seq_page_cost = 1.0`	определяет стоимость последовательного чтения страницы таблицы.

`#random_page_cost = 4.0`	определяет стоимость случайного чтения страницы таблицы.

`#cpu_tuple_cost = 0.01`	определяет стоимость обработки кортежа.

`#cpu_index_tuple_cost = 0.005`	определяет стоимость обработки индексного кортежа.

`#cpu_operator_cost = 0.0025`	определяет стоимость выполнения оператора.

`#parallel_setup_cost = 1000.0`	определяет стоимость настройки параллельного выполнения операции.

`#parallel_tuple_cost = 0.1`	определяет стоимость обработки кортежа в параллельном выполнении.

`#min_parallel_table_scan_size = 8MB`	минимальный размер таблицы, для которой будет использовано параллельное сканирование.

`#min_parallel_index_scan_size = 512kB`	минимальный размер индекса, для которого будет использовано параллельное сканирование.

`#effective_cache_size = 4GB`	приблизительное значение размера кэша, используемого для хранения данных.

`#jit_above_cost = 100000`	задает пороговое значение стоимости выполнения запроса, выше которого задействуется Just-In-Time (JIT) компиляция.

`#jit_inline_above_cost = 500000`	задает пороговое значение стоимости выполнения оператора, выше которого операторы могут быть встроены в генерируемый код JIT компилятором.

`#jit_optimize_above_cost = 500000`	задает пороговое значение стоимости выполнения оператора, выше которого операторы будут оптимизированы JIT компилятором.


##### - Оптимизатор генетических запросов (Genetic Query Optimizer) -

GEQO работает как альтернативный метод оптимизации запросов и может оказывать влияние на производительность. 

`#geqo = on`	включает использование GEQO.

`#geqo_threshold = 12`	адает пороговое значение, при котором GEQO будет применяться. Если количество таблиц в запросе превышает это значение, GEQO будет использоваться для оптимизации плана запроса.

`#geqo_effort = 5`	(1-10) устанавливает уровень усилий, затрачиваемых на генетическую оптимизацию.

`#geqo_pool_size = 0`	определяет размер пула планов, генерируемых GEQO. Значение 0 означает автоматическое определение в зависимости от размерности запроса.

`#geqo_generations = 0`	определяет количество генераций в генетическом алгоритме. Значение 0 означает автоматическое определение.

`#geqo_selection_bias = 2.0`	(1.5-2.0) определяет степень предпочтения выбора лучших планов в генетическом алгоритме.

`#geqo_seed = 0.0`	(0.0-1.0) устанавливает начальное значение для генератора случайных чисел в GEQO. Значение 0.0 использует системное время в качестве зерна.


##### - Другие настройки планировщика (Other Planner Options) -

`#default_statistics_target = 100`	(1-10000) определяет количество "статистических целей" по-умолчанию, используемых при анализе запроса и выборе плана выполнения. Большее значение может привести к более точным статистическим данным, но также может увеличить время анализа запроса.

`#constraint_exclusion = partition`	(on, off, или partition) определяет, какие ограничения (constraints) будут использоваться при планировании запросов: включение ограничений средствами разделения (partition) или отключение ограничений на уровне планировщика. Значение `partition` указывает на использование разделенных ограничений, `on` - на использование всех ограничений включая разделенные, а `off` - на отключение ограничений при планировании.

`#cursor_tuple_fraction = 0.1` (0.0-1.0) определяет долю числа строк, которые будут скопированы из результата запроса в курсор. Значение 0.1 указывает на то, что будет скопирована 10% строк результата.

`#from_collapse_limit = 8`	определяет максимальное количество вложенных уровней FROM в запросе, которые могут быть объединены при оптимизации запроса.

`#jit = on`	определяет использование Just-In-Time (JIT) компиляции для выполнения запросов. Значение `on` включает JIT-компиляцию, а значение `off` отключает ее.

`#join_collapse_limit = 8`	определяет максимальное количество табличных выражений (JOIN) в запросе, которые могут быть скомбинированы в одно JOIN при оптимизации.

`#plan_cache_mode = auto`	(auto, force_generic_plan или force_custom_plan) Определяет режим работы планового кэша. Значение `auto` позволяет PostgreSQL самостоятельно выбирать наилучший режим работы, основываясь на текущей нагрузке и характеристиках системы.


----------------------------
### ОТЧЕТНОСТЬ И ЛОГИРОВАНИЕ
----------------------------

##### - Где логи (Where to Log) -

`#log_destination = 'stderr'`	определяет, куда будут направляться журнальные сообщения. В данном случае, они будут направляться в stderr (стандартный вывод ошибок).

`#logging_collector = off`	определяет, будет ли использоваться специальный процесс-сборщик журнала для записи сообщений в файлы вместо отправки их в stderr.

`#log_directory = 'log'`	задает каталог, в котором будут сохраняться журнальные файлы.

`#log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'`	определяет формат имени файла журнала, включая возможность использования шаблонов даты и времени (%Y-%m-%d_%H%M%S).

`#log_file_mode = 0600`	указывает права доступа (mode) для создаваемых журнальных файлов.

`#log_rotation_age = 1d`	определяет, через какое время происходит поворот (ротация) журнальных файлов по времени.

`#log_rotation_size = 10MB`	позволяет ограничить размер журнальных файлов, после достижения которого будет выполняться поворот.

`#log_truncate_on_rotation = off`	определяет, будет ли обрезать (truncate) текущий журнальный файл при его повороте.

`#syslog_facility = 'LOCAL0'`	указывает, к какой категории syslog будут привязаны журнальные сообщения.

`#syslog_ident = 'postgres'`	указывает идентификатор, который будет добавлен к журнальным сообщениям для их идентификации в системе syslog.

`#syslog_sequence_numbers = on`	определяет, будут ли добавляться последовательные номера к журнальным сообщениям.

`#syslog_split_messages = on`	указывает, будут ли длинные сообщения разбиваться на несколько строк в системе syslog.

`#event_source = 'PostgreSQL'`	определяет источник журнальных сообщений в системе, как правило, название программы или службы (в данном случае PostgreSQL).


##### - Когда логи (When to Log) -

`#log_min_messages = warning`	устанавливает минимальный уровень журналирования для сообщений. В данном случае, установлен уровень "warning", что означает, что будут журналироваться только предупреждающие сообщения и сообщения более высокого уровня. Значения в порядке убывания детализации: <em>debug5, debug4, debug3, debug2, debug1, info, notice, warning, error, log, fatal, panic</em>.

`#log_min_error_statement = error`	устанавливает минимальный уровень журналирования для ошибок в SQL-запросах. В данном случае, установлен уровень "error", что означает, что будут журналироваться только ошибки в SQL-запросах. Значения в порядке убывания детализации: <em>debug5, debug4, debug3, debug2, debug1, info, notice, warning, error, log, fatal, panic</em>.

`#log_min_duration_statement = -1`	устанавливает минимальную продолжительность выполнения SQL-запросов, при которой они будут журналироваться. Значение -1 означает, что все SQL-запросы будут журналироваться.

`#log_min_duration_sample = -1`	 устанавливает минимальную продолжительность выполнения SQL-запросов, при которой они будут выборочно журналироваться. Значение -1 означает, что выборочное журналирование не используется.

`#log_statement_sample_rate = 1.0`	устанавливает частоту выборочного журналирования SQL-запросов, когда `log_min_duration_sample` включен. Значение 1.0 означает, что все соответствующие SQL-запросы будут журналироваться.

`#log_transaction_sample_rate = 0.0`	устанавливает частоту выборочного журналирования транзакций. Значение 0.0 означает, что выборочное журналирование транзакций не используется.


##### - Что в логах (What to Log) -

`#debug_print_parse = off`	определяет, будет ли выводиться отладочная информация при парсинге SQL-запросов.

`#debug_print_rewritten = off`	определяет, будет ли выводиться отладочная информация при переписывании SQL-запросов.

`#debug_print_plan = off`	определяет, будет ли выводиться отладочная информация о плане выполнения SQL-запросов.

`#debug_pretty_print = on`	определяет, будет ли форматироваться красивый вывод отладочной информации.

`#log_autovacuum_min_duration = -1`	определяет минимальную продолжительность автоочистки, при которой будет производиться запись логов.

`#log_checkpoints = off`	определяет, будут ли записываться логи о контрольных точках.

`#log_connections = off`	определяет, будут ли записываться логи о подключениях к базе данных.

`#log_disconnections = off`	определяет, будут ли записываться логи о отключениях от базы данных.

`#log_duration = off`	определяет, будут ли записываться логи о продолжительности выполнения SQL-запросов.

`#log_error_verbosity = default`	(terse, default, или verbose messages) определяет уровень детализации логов об ошибках.

`#log_hostname = off`	определяет, будет ли записываться имя хоста в логи.

`log_line_prefix = '%m [%p] %q%u@%d '`	определяет формат строки префикса для каждой записи в лог-файле. Специальные символы:
* %a = имя приложения
* %u = имя пользователя
* %d = имя базы данных
* %r = удаленный хост и порт
* %h = удаленный хост
* %b = тип бэкенда
* %p = id процесса
* %P = id процесса лидера параллельной группы
* %t = временная метка без милисекунд
* %m = временная метка в милисекундах
* %n = временная метка в милисекундах (как эпоха Unix)
* %Q = id запроса (0 если он отсутствует или не вычислен)
* %i = тег команды
* %e = состояние SQL
* %c = id сеанса
* %l = номер строки сеанса
* %s = отметка времени начала сеанса
* %v = id виртуальной транзакции
* %x = id транзакции (0 если нет)
* %q = остановиться здесь в несессионных процессах
* %% = '%'
* e.g. '<%u%%%d>'

`#log_lock_waits = off`	определяет, будут ли записываться логи о блокировках процессов.

`#log_recovery_conflict_waits = off`	определяет, будут ли записываться логи о конфликтах при восстановлении базы данных.

`#log_parameter_max_length = -1`	определяет максимальную длину вывода значений параметров в логах.

`#log_parameter_max_length_on_error = 0`	определяет максимальную длину вывода значений параметров при ошибке. 

`#log_statement = 'none'`	(none, ddl, mod, all) определяет типы SQL-запросов, для которых будет производиться запись логов.

`#log_replication_commands = off`	определяет, будут ли записываться логи о командах репликации.

`#log_temp_files = -1`	определяет минимальный размер временных файлов для записи логов.

`log_timezone = 'Europe/Moscow'`	определяет временную зону для записи времени в логах.


-------------------------------------
### НАЗВАНИЕ ПРОЦЕССА (PROCESS TITLE)
-------------------------------------

`cluster_name = '14/main'`	определяет имя кластера. Кластер - это набор баз данных, работающих на одном сервере PostgreSQL. Указанное значение будет добавлено к заголовку процесса PostgreSQL.

`#update_process_title = on`	если эта настройка установлена в "on", PostgreSQL будет обновлять заголовок процесса с текущей выполняемой командой. Это может быть полезно при отладке или наблюдении за работой PostgreSQL.

Если эта настройка установлена в "on", PostgreSQL будет обновлять заголовок процесса с текущей выполняемой командой. Это может быть полезно при отладке или наблюдении за работой PostgreSQL.


--------------
### СТАТИСТИКА
--------------

##### - Сборщик статистики запросов и индексов -

`#track_activities = on`	включает отслеживание активности пользователей и сеансов подключения к базе данных.

`#track_activity_query_size = 1024`	задает максимальный размер сохраняемого SQL-запроса для отслеживания активности.

`#track_counts = on`	включает отслеживание количества строк, вставленных, обновленных и удаленных в каждой таблице.

`#track_io_timing = off`	включает отслеживание времени операций ввода-вывода.Включает отслеживание времени операций ввода-вывода.

`#track_wal_io_timing = off`	включает отслеживание времени операций ввода-вывода журналов транзакций (WAL).

`#track_functions = none`	задает уровень отслеживания вызовов пользовательских функций (none - без отслеживания, pl - только для функций, all - для всех функций).

`stats_temp_directory = '/var/run/postgresql/14-main.pg_stat_tmp'`	задает временную директорию для хранения временных файлов статистики.


##### - Мониторинг -

`#compute_query_id = auto`	определяет, будет ли вычисляться идентификатор запроса для каждого SQL-запроса. Значение "auto" включает вычисление идентификатора запроса в зависимости от других настроек. 

`#log_statement_stats = off`	указывает, должна ли быть включена запись статистики выполнения для каждого SQL-запроса в журнал.

`#log_parser_stats = off`	определяет, должна ли быть включена запись статистики парсинга SQL-запросов в журнал.

`#log_planner_stats = off`	указывает, должна ли быть включена запись статистики планировщика выполнения SQL-запросов в журнал.

`#log_executor_stats = off`	определяет, должна ли быть включена запись статистики выполнения SQL-запросов в журнал.


--------------
### AUTOVACUUM
--------------

`#autovacuum = on`	указывает, будет ли включена автоматическая очистка (автовакуум) для базы данных.

`#autovacuum_max_workers = 3`	максимальное количество процессов автовакуума, которые могут выполняться одновременно.

`#autovacuum_naptime = 1min`	время ожидания между проверками таблиц для автовакуума.

`#autovacuum_vacuum_threshold = 50`	минимальное число модифицированных или удаленных строк перед выполнением очистки (VACUUM).

`#autovacuum_vacuum_insert_threshold = 1000`	минимальное число вставленных строк перед выполнением очистки (VACUUM).

`#autovacuum_analyze_threshold = 50`	минимальное число модифицированных или удаленных строк перед выполнением анализа.

`#autovacuum_vacuum_scale_factor = 0.2`	процент модифицированных или удаленных строк для выполнения очистки относительно общего числа строк в таблице.

`#autovacuum_vacuum_insert_scale_factor = 0.2`	процент вставленных строк для выполнения очистки относительно общего числа строк в таблице.

`#autovacuum_analyze_scale_factor = 0.1`	процент модифицированных или удаленных строк для выполнения анализа относительно общего числа строк в таблице.

`#autovacuum_freeze_max_age = 200000000`	максимальный возраст транзакции (в количестве транзакций), после которого строки становятся "замороженными" и требуют очистки мертвых кортежей.

`#autovacuum_multixact_freeze_max_age = 400000000`	максимальный возраст множественной транзакции (в количестве транзакций), после которого множественные кортежи становятся "замороженными" и требуют очистки.

`#autovacuum_vacuum_cost_delay = 2ms`	задержка (временной промежуток) между итерациями VACUUM для контроля стоимости.

`#autovacuum_vacuum_cost_limit = -1`	максимальная общая стоимость VACUUM, за которую он может выполняться одновременно с другими операциями.


------------------------------------
### ПОДКЛЮЧЕНИЕ КЛИЕНТА ПО-УМОЛЧАНИЮ
------------------------------------

##### - Поведение оператора -

`#client_min_messages = notice`	определяет минимальный уровень сообщений, которые будут отправлены клиенту. Значение "notice" означает, что клиент будет получать только уведомления. Значения в порядке убывания детализации: <em>debug5, debug4, debug3, debug2, debug1, log, notice, warning, error</em>.

`#search_path = '"$user", public'`	определяет список схем, разделенных запятыми, в которых PostgreSQL будет искать объекты базы данных (таблицы, представления и т. д.).

`#row_security = on`	включает или отключает механизм защиты строк, который ограничивает доступ к строкам таблицы в зависимости от определенных прав доступа.

`#default_table_access_method = 'heap'`	определяет метод доступа к таблицам. Значение `heap` означает использование стандартного метода хранения данных.

`#default_tablespace = ''`	определяет таблицу по-умолчанию для размещения новых объектов базы данных.

`#default_toast_compression = 'pglz'`	('pglz' или 'lz4')	определяет метод сжатия для TOAST-таблиц (таблиц, содержащих большие значения) по-умолчанию.

`#temp_tablespaces = ''`	определяет список таблиц временных файловых пространств, разделенных запятыми.

`#check_function_bodies = on`	определяет, будет ли проверяться тело функций при их создании.

`#default_transaction_isolation = 'read committed'`	определяет уровень изоляции транзакций по-умолчанию.

`#default_transaction_read_only = off`	указывает, будут ли транзакции по-умолчанию только для чтения.

`#default_transaction_deferrable = off`	указывает, будут ли транзакции по-умолчанию откладываемыми.

`#session_replication_role = 'origin'`	определяет роль репликации сессии.

`#statement_timeout = 0`	определяет максимальное время выполнения для отдельного SQL-запроса.

`#lock_timeout = 0`	определяет максимальное время ожидания блокировок.

`#idle_in_transaction_session_timeout = 0`	определяет максимальное время простоя для транзакций внутри сеанса.

`#idle_session_timeout = 0`	определяет максимальное время простоя для активного сеанса.

`#vacuum_freeze_table_age = 150000000`	указывает минимальный возраст строки таблицы, при котором она может быть заморожена в процессе выполнения операции VACUUM.

`#vacuum_freeze_min_age = 50000000`	определяет минимальный возраст строки таблицы, при котором такая строка может быть выбрана для заморозки во время операции VACUUM.

`#vacuum_failsafe_age = 1600000000`	определяет число транзакций, при достижении которого строки таблицы будут замораживаться автоматически, независимо от их возраста.

`#vacuum_multixact_freeze_table_age = 150000000`	определяет минимальный возраст строки таблицы для заморозки в процессе операции VACUUM, связанной с множественными транзакциями.

`#vacuum_multixact_freeze_min_age = 5000000`	задает минимальный возраст строки таблицы, при котором она может быть выбрана для заморозки в процессе VACUUM, связанной с множественными транзакциями.

`#vacuum_multixact_failsafe_age = 1600000000`	определяет число транзакций, при достижении которого строки таблицы будут автоматически замораживаться в процессе VACUUM, связанной с множественными транзакциями.

`#bytea_output = 'hex'`	определяет формат вывода значений типа bytea. Значение 'hex' означает вывод в шестнадцатеричном формате, а 'escape' - в формате с экранированием.	

`#xmlbinary = 'base64'`	задает предпочтительный формат кодирования данных XML. 'base64' означает кодирование с использованием base64.

`#xmloption = 'content'`	определяет, какой тип контента будет предоставляться по-умолчанию при чтении и записи значений XML. Значение 'content' означает, что будет предоставляться только содержимое XML.

`#gin_pending_list_limit = 4MB`	устанавливает максимальный размер ожидающего списка операций индекса с общими неположенными элементами. Значение 4MB означает, что размер ограничен 4 мегабайтами.


##### - Локализация и форматирование -

`datestyle = 'iso, dmy' определяет формат даты и времени, используемый при вставке и извлечении данных из базы данных. Настройка 'iso, dmy' указывает формат даты в стиле ISO с днем, месяцем и годом.

`#intervalstyle = 'postgres'`	определяет формат вывода интервалов времени.

`timezone = 'Europe/Moscow'`	определяет часовой пояс базы данных.

`#timezone_abbreviations = 'Default'`	определяет использование сокращений часовых поясов при разборе и отображении даты и времени.

`#extra_float_digits = 1`	(min -15, max 3) определяет количество дополнительных знаков, отображаемых при выводе чисел с плавающей точкой. Значение 1 указывает, что может отображаться 1 дополнительный знак.

`#client_encoding = sql_ascii`	определяет кодировку, используемую для обмена данными между клиентом и сервером PostgreSQL. Значение 'sql_ascii' указывает кодировку, в которой все символы за пределами ASCII набора отображаются как '?'. Это не наилучший выбор для международных данных.


<em><b>Эти настройки инициализируются initdb, но их можно изменить:</b></em>

`lc_messages = 'en_US.UTF-8'`	устанавливает локализацию для сообщений в базе данных на английский язык с использованием кодировки UTF-8.

`lc_monetary = 'ru_RU.UTF-8'`	устанавливает локализацию для форматирования денежных значений на русский язык с использованием кодировки UTF-8.

`lc_numeric = 'ru_RU.UTF-8'`	устанавливает локализацию для форматирования числовых значений на русский язык с использованием кодировки UTF-8.

`lc_time = 'ru_RU.UTF-8'`	устанавливает локализацию для форматирования даты и времени на русский язык с использованием кодировки UTF-8.


<em><b>Конфигурация по-умолчанию для текстового поиска:</b></em>

`default_text_search_config = 'pg_catalog.english'`	определяет конфигурацию поиска текста по умолчанию в PostgreSQL. Значение 'pg_catalog.english' указывает на используемый язык и словарь для полнотекстового поиска, в данном случае - английский язык. Можно изменить это значение на другой язык или словарь, чтобы настроить поиск текста под конкретные требования приложения или языка.


###### - Предварительная загрузка общей библиотеки -

`#local_preload_libraries = ''`	указывает список разделяемых библиотек, которые будут загружены перед выполнением кода в локальной сессии.

`#session_preload_libraries = ''`	указывает список разделяемых библиотек, которые будут загружены перед выполнением кода в каждой сессии.

`#shared_preload_libraries = ''`	указывает список разделяемых библиотек, которые будут загружены перед запуском PostgreSQL.

`#jit_provider = 'llvmjit'`	указывает провайдера JIT (Just-In-Time), который используется для оптимизации кода. Значение 'llvmjit' означает использование LLVM-based JIT Provider.


##### - Другие значения по-умолчанию -

`#dynamic_library_path = '$libdir'`	определяет путь к динамическим библиотекам (например, расширениям), которые можно загружать в PostgreSQL.

`#extension_destdir = ''`	определяет каталог, в который будут установлены файлы расширений PostgreSQL.

`#gin_fuzzy_search_limit = 0`	определяет максимальное число результатов при нечётком поиске Gin. Значение 0 указывает на отсутствие ограничения по количеству результатов.


---------------------------------------------
### УПРАВЛЕНИЕ БЛОКИРОВКАМИ (LOCK MANAGEMENT)
---------------------------------------------

Настройки LOCK MANAGEMENT отвечают за управление блокировками в PostgreSQL. Блокировки используются для обеспечения согласованности и безопасности при одновременном доступе к данным из разных сеансов.

`#deadlock_timeout = 1s`	определяет период времени, по истечении которого сервер обяжет запрос, ставший жертвой взаимоблокировки (deadlock), отмениться, чтобы разрешить блокировку.

`#max_locks_per_transaction = 64`	(min 10) ограничивает количество блокировок, которые может получить одна транзакция. Если транзакция пытается заблокировать больше, чем это число, то она будет прервана.

`#max_pred_locks_per_transaction = 64`	(минимум 10) определяет максимальное количество прогнозируемых блокировок, которые может получить транзакция.

`#max_pred_locks_per_relation = -2`	определяет максимальное количество предикативных блокировок, которые могут быть установлены на одну таблицу. Предикативные блокировки используются для оптимизации обновлений таблиц, чтобы предотвратить конфликтные обновления. Значение -2 указывает на использование параметра `max_locks_per_transaction` для определения количества блокировок на таблицу.

`#max_pred_locks_per_page = 2`	(минимум 0) определяет максимальное количество предикативных блокировок, которые могут быть установлены на одну страницу таблицы. Предикативные блокировки на страницу используются для предотвращения конфликтных чтений и записей в таблицу на уровне страницы. Значение 2 указывает, что максимум 2 блокировки могут быть на странице.


-----------------------------------
### СОВМЕСТИМОСТЬ ВЕРСИЙ И ПЛАТФОРМ
-----------------------------------

##### - Предыдущие версии PostgreSQL -

`#array_nulls = on`	определяет, как обрабатывать NULL-значения в массивах. Если установлено значение `on`, то при сравнении массивов с NULL-значениями будет использоваться semantic equality. Если установлено значение `off`, NULL-значения в массивах будут игнорироваться при сравнении.

`#backslash_quote = safe_encoding`	(on, off, или safe_encoding) определяет, как интерпретировать обратную косую черту (\) при цитировании строковых литералов. Значение `safe_encoding` указывает, что обратная косая черта будет экранировать только специальные символы, зависящие от кодировки.

`#escape_string_warning = on`	если установлено значение `on`, PostgreSQL будет выдавать предупреждающее сообщение, если в строке символы "escape" используются без необходимости.

`#lo_compat_privileges = off`	если установлено значение `on`, пользователи будут иметь возможность выполнять некоторые команды на больших объектах (large objects) без необходимости обладать соответствующими привилегиями. Если установлено значение `off`, пользователи должны иметь соответствующие привилегии для работы с большими объектами.

`#quote_all_identifiers = off`	определяет, должны ли идентификаторы, такие как таблицы и столбцы, всегда быть заключены в кавычки при использовании. Если установлено значение `on`, идентификаторы будут автоматически заключены в кавычки при использовании. Если установлено значение `off`, идентификаторы будут заключены в кавычки только в случае, если это необходимо (например, если идентификатор содержит специальные символы).

`#standard_conforming_strings = on`	если установлено значение `on`, SQL-литералы строк должны соответствовать стандарту SQL и требуют экранирования строковых значений с помощью одиночных кавычек. Если установлено значение `off`, строковые значения могут быть экранированы с помощью обратной косой черты (\).

`#synchronize_seqscans = on`	определяет, должны ли операции сканирования последовательностей выполняться синхронно или нет. Если установлено значение `on`, PostgreSQL будет выполнять сканирование последовательностей синхронно, что может замедлить выполнение запросов, но обеспечивает последовательность результатов. Если установлено значение `off`, сканирование последовательностей будет выполняться асинхронно, что может повысить производительность за счет параллельного выполнения.

##### - Другие платформы -

`#transform_null_equals = off`	определяет, каким образом PostgreSQL будет обрабатывать оператор сравнения NULL. Значение `off` означает, что PostgreSQL будет рассматривать операторы сравнения NULL как различные. То есть, если имеется сравнение `NULL = NULL`, оно будет возвращать значение `false`, потому что значение NULL не равно другим значениям, включая другое значение NULL. Если настройка установлена на `on`, то операторы NULL будут трактоваться как эквивалентные, и сравнение `NULL = NULL` будет возвращать значение `true`.


--------------------
### ОБРАБОТКА ОШИБОК
--------------------

Эти настройки позволяют настроить поведение PostgreSQL в случае ошибок и при восстановлении после сбоев.

`#exit_on_error = off`	если эта опция установлена в "on", сервер PostgreSQL будет аварийно завершаться при возникновении фатальной ошибки. В случае установки в "off", сервер будет продолжать работу после обработки ошибки.

`#restart_after_crash = on`	если эта опция установлена в "on", сервер PostgreSQL будет автоматически перезапускаться после сбоев. В случае установки в "off", сервер не будет автоматически перезапускаться и требуется ручное восстановление.

`#data_sync_retry = off`	если эта опция установлена в "on", сервер PostgreSQL будет пытаться синхронизировать данные с диском в случае ошибок синхронизации. В случае установки в "off", сервер не будет повторять попытки синхронизации данных при ошибке.

`#recovery_init_sync_method = fsync`	(fsync, syncfs (Linux 5.8+)) эта опция управляет способом синхронизации данных при инициализации восстановления. Значение "fsync" гарантирует, что данные полностью записаны на диск. Другой вариант - "syncfs" - гарантирует, что данные выводятся на диск перед тем, как файл закрывается.


--------------------------------------------------------
### ВКЛЮЧАЕМЫЕ ФАЙЛЫ КОНФИГУРАЦИИ (CONFIG FILE INCLUDES)
--------------------------------------------------------

Эти параметры позволяют загружать настройки из файлов, отличных от postgresql.conf по-умолчанию. Обратите внимание, что это директивы, а не переменные назначения, поэтому их можно задавать более одного раза.

`include_dir = 'conf.d'`	устанавливает каталог, в котором будут находиться дополнительные конфигурационные файлы. Все файлы с расширением .conf в этом каталоге будут автоматически включены при запуске PostgreSQL. Это может быть полезно, чтобы разделить основные настройки от специфических для конкретных приложений.

`#include_if_exists = '...'`	позволяет включать конфигурационные файлы только в том случае, если они существуют. Вы можете указать путь к конкретному файлу и, если он существует, его содержимое будет включено в основной конфигурационный файл. Это может быть полезно, когда вы хотите иметь конфигурационные файлы определенных приложений, но не хотите, чтобы они были обязательными.

`#include = '...'`	позволяет явно указывать путь к файлу, который следует включить в основной конфигурационный файл. Это может быть полезно, если у вас есть отдельные файлы с настройками, которые вы хотите включить, но которые не находятся в основном каталоге конфигурации.


------------------------------
### Пользовательские настройки
------------------------------

##### Сюда можно добавить настройки расширений
