# Оптимизация запросов

Можно выделить два основных подхода оптимизации. Первый состоит в том, чтобы отслеживать состояние системы и добиваться того, чтобы она справлялась с имеющейся нагрузкой. Для этого можно настраивать параметры СУБД, а также настраивать операционную систему. Если настройки не помогают, при таком подходе остается только модернизировать аппаратуру (что тоже помогает не всегда).

Другой подход состоит в том, чтобы не приспосабливаться под нагрузку, а уменьшать ее. 'Полезная' нагрузка формируется запросами. Если удается найти узкое место, то можно попробовать тем или иным способом повлиять на выполнение запроса и получить тот же результат, потратив меньше ресурсов. Такой способ действует более локально (на отдельный запрос или ряд запросов), но уменьшение нагрузки благоприятно сказывается и на работе всей системы.

Обычный удобный способ узнать время выполнения и время планирования — команда `EXPLAIN ANALYZE`. Ее основное назначение — показать план выполнения запроса.

Этапы, которые проходит запрос для получения результата:
1. Подключение к серверу PostgreSQL,
2. Синтаксическая проверка запроса, создание дерева запроса,
3. Система правил принимает дерево запроса и ищет в системных каталогах правила для применения к этому дереву. Обнаружив подходящие правила, она выполняет преобразования, заданные в теле правил,
4. Планировщик/оптимизатор принимает дерево запроса и создаёт план запроса. Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же результата. Затем оценивается стоимость каждого варианта и выбирается самый дешёвый. Затем выбранный вариант разворачивается в полноценный план, который сможет использовать исполнитель.
5. Исполнитель рекурсивно проходит по дереву плана и получает строки тем способом, который указан в плане. Он сканирует отношения, обращаясь к системе хранения, выполняет сортировку и соединения, вычисляет условия фильтра и, наконец, возвращает полученные строки.


### JIT

Динамическая компиляция JIT (just-in-time, 'точно в нужное время') используется для компиляции кода или его фрагментов в момент выполнения программы. Эта технология позволяет ускорить выполнение интерпретируемого кода и используется во многих системах. В PostgreSQL с помощью JIT-компиляции можно скомпилировать часть кода, который выполняется при работе запросов SQL. Для этого PostgreSQL должен быть собран с поддержкой LLVM. JIT-компиляция лучше подходит для длительных, нагружающих процессор аналитических запросов. Для коротких OLTP-запросов накладные расходы на JIT-компиляцию могут превышать время выполнения самих запросов. Влиять на JIT-компиляцию можно с помощью конфигурационных параметров. Есть несколько оптимизаций, связанных с JIT, они включаются, только если стоимость запроса превышает указанное в соответствующих параметрах граничное значение.

`SHOW jit;`     проверка, включен ли параметр (по-умолчанию включен)
`SET jit = off;`    отключение параметра


### Sec Scan

Последовательное сканирование - файл (или файлы) таблицы читается постранично от начала до конца. При этом рассматриваются все версии строк на каждой странице: удовлетворяют ли они условиям запроса и соблюдены ли правила видимости. 

Последовательное чтение файла позволяет использовать тот факт, что операционная система обычно читает данные порциями больше, чем размер страницы: с большой вероятностью несколько следующих страниц уже окажутся в кеше операционной системы. 

Последовательное сканирование эффективно работает, когда надо прочитать всю таблицу или значительную ее часть. Если же из всей таблицы нужна только небольшая часть записей, более предпочтительными являются методы доступа, использующие индекс.

```sql
EXPLAIN SELECT * FROM flights;


                           QUERY PLAN                           
----------------------------------------------------------------
Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)
(1 row)
```

* cost — оценка стоимости
* rows — оценка числа строк, возвращаемых операцией
* width — оценка размера одной записи в байтах

Стоимость указывается в некоторых условных единицах и состоит из двух компонент: начальной стоимости вычисления узла и полной стоимости для вычисления всех компонент.


###### Aggregate

```sql
EXPLAIN SELECT count(*) FROM seats;


                          QUERY PLAN                           
---------------------------------------------------------------
Aggregate  (cost=24.74..24.75 rows=1 width=8)
   ->  Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=0)
(2 rows)
```

План состоит из двух узлов. Верхний - Aggregate, в котором происходит вычисление count, - получает данные от нижнего - `Seq Scan`. Узел не может выдать результат, пока не обработает все данные, поэтому начальная стоимость в Aggregate практически равна полной.


### Parallel Seq Scan

Параллельное последовательное сканирование - страницы таблицы читаются последовательно, в том же самом порядке, в котором они читались бы при обычном последовательном сканировании. Однако запросы на чтение выдаются несколькими параллельно работающими процессами. Процессы синхронизируются между собой, чтобы их запросы шли в правильном порядке. Преимущество такого сканирования проявляется в том, что параллельные процессы одновременно обрабатывают свои страницы.

Число одновременно выполняющихся рабочих процессов, обслуживающих один ведущий процесс, ограничено параметром `max_parallel_workers_per_gather` (по умолчанию 2).

Планировщик вообще не будет рассматривать параллельное сканирование, если физический размер таблицы меньше значения параметра `min_parallel_table_scan_size`. Например, для стандартного значения `min_parallel_table_scan_size` = 8MB:

```sql
SHOW min_parallel_table_scan_size;

 min_parallel_table_scan_size 
------------------------------
 8MB
(1 row)
```

|Размер таблицы|ОКоличество процессов|
|---|---|
|8MB|1|
|24MB|2|
|72MB|3|
|216MB|4|
|648MB|5|
|1.9GB|6|

Число процессов можно и явно указать в параметре хранения `parallel_workers` таблицы.


Не распараллеливаются:
* Запросы, изменяющие или блокирующие данные (UPDATE, DELETE, SELECT FOR UPDATE и т. п.).
* Запросы, выполнение которых может быть приостановлено — это относится к запросам в курсорах, в том числе в циклах FOR PL/pgSQL.
* Запросы, содержащие функции, помеченные как PARALLEL UNSAFE.
* Запросы, содержащиеся в функциях, которые вызываются из распараллеленного запроса


```sql
EXPLAIN SELECT count(*) FROM bookings;


                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=25442.58..25442.59 rows=1 width=8)
   ->  Gather  (cost=25442.36..25442.57 rows=2 width=8)
         Workers Planned: 2
         ->  Partial Aggregate  (cost=24442.36..24442.37 rows=1 width=8)
               ->  Parallel Seq Scan on bookings  (cost=0.00..22243.29 rows=879629 width=0)
(5 rows)
```

Все, что находится ниже узла Gather — параллельная часть плана. Она выполняется в каждом из рабочих процессов (которых запланировано два) и, возможно, в ведущем процессе. Узел Gather и все узлы выше выполняются только в ведущем процессе. Это последовательная часть плана.

Узел `Gather` и все узлы выше выполняются только в ведущем процессе. Это последовательная часть плана. Далее разбор пойдет снизу вверх по телу плана:

* Узел `Parallel Seq Scan` представляет сканирование таблицы в параллельном режиме. В поле rows показана оценка числа строк, которые обработает один рабочий процесс. Всего их запланировано 2, и еще часть работы выполнит ведущий, поэтому общее число строк делится на 2.4 (доля ведущего процесса уменьшается с ростом числа рабочих процессов). Для оценки узла `Parallel Seq Scan` компонента ввода-вывода берется полностью, а ресурсы процессора делятся между процессами (на 2.4 в данном случае).

* Узел `Partial Aggregate` выполняет агрегацию данных, полученных рабочим процессом, то есть в данном случае подсчитывает количество строк. 

* Узел `Gather` выполняется ведущим процессом. Он отвечает за запуск рабочих процессов и получение от них данных.

* Узел `Finalize Aggregate` агрегирует полученные частичные агрегаты. Поскольку для этого надо сложить всего три числа, оценка минимальна.


##### Пометки параллельности для функций и агрегатов

Для функций существует три типа пометок параллельности:

1. `PARALLEL SAFE` — не препятствует параллельному выполнению запроса;
2. `PARALLEL UNSAFE` — запрещает параллельное выполнение запроса (функция изменяет состояние базы данных, транзакции или конфигурационных параметров), пользовательские функции по умолчанию получают пометку `PARALLEL UNSAFE`.;
3. `PARALLEL RESTRICTED` — запрос может выполняться параллельно, но функция может выполняться только в ведущем процессе (функция обращается к состоянию сеанса: к временным таблицам, курсорам, подготовленным операторам и т. п.).