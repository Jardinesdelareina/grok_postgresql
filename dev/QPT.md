# Оптимизация запросов

Можно выделить два основных подхода оптимизации. Первый состоит в том, чтобы отслеживать состояние системы и добиваться того, чтобы она справлялась с имеющейся нагрузкой. Для этого можно настраивать параметры СУБД, а также настраивать операционную систему. Если настройки не помогают, при таком подходе остается только модернизировать аппаратуру (что тоже помогает не всегда).

Другой подход состоит в том, чтобы не приспосабливаться под нагрузку, а уменьшать ее. 'Полезная' нагрузка формируется запросами. Если удается найти узкое место, то можно попробовать тем или иным способом повлиять на выполнение запроса и получить тот же результат, потратив меньше ресурсов. Такой способ действует более локально (на отдельный запрос или ряд запросов), но уменьшение нагрузки благоприятно сказывается и на работе всей системы.

Обычный удобный способ узнать время выполнения и время планирования — команда `EXPLAIN ANALYZE`. Ее основное назначение — показать план выполнения запроса.

Этапы, которые проходит запрос для получения результата:
1. Подключение к серверу PostgreSQL,
2. Синтаксическая проверка запроса, создание дерева запроса,
3. Система правил принимает дерево запроса и ищет в системных каталогах правила для применения к этому дереву. Обнаружив подходящие правила, она выполняет преобразования, заданные в теле правил,
4. Планировщик/оптимизатор принимает дерево запроса и создаёт план запроса. Он выбирает план, сначала рассматривая все возможные варианты получения одного и того же результата. Затем оценивается стоимость каждого варианта и выбирается самый дешёвый. Затем выбранный вариант разворачивается в полноценный план, который сможет использовать исполнитель.
5. Исполнитель рекурсивно проходит по дереву плана и получает строки тем способом, который указан в плане. Он сканирует отношения, обращаясь к системе хранения, выполняет сортировку и соединения, вычисляет условия фильтра и, наконец, возвращает полученные строки.


### JIT

Динамическая компиляция JIT (just-in-time, 'точно в нужное время') используется для компиляции кода или его фрагментов в момент выполнения программы. Эта технология позволяет ускорить выполнение интерпретируемого кода и используется во многих системах. В PostgreSQL с помощью JIT-компиляции можно скомпилировать часть кода, который выполняется при работе запросов SQL. Для этого PostgreSQL должен быть собран с поддержкой LLVM. JIT-компиляция лучше подходит для длительных, нагружающих процессор аналитических запросов. Для коротких OLTP-запросов накладные расходы на JIT-компиляцию могут превышать время выполнения самих запросов. Влиять на JIT-компиляцию можно с помощью конфигурационных параметров. Есть несколько оптимизаций, связанных с JIT, они включаются, только если стоимость запроса превышает указанное в соответствующих параметрах граничное значение.

`SHOW jit;`     проверка, включен ли параметр (по-умолчанию включен)
`SET jit = off;`    отключение параметра


### Sec Scan

Последовательное сканирование - файл (или файлы) таблицы читается постранично от начала до конца. При этом рассматриваются все версии строк на каждой странице: удовлетворяют ли они условиям запроса и соблюдены ли правила видимости. 

Последовательное чтение файла позволяет использовать тот факт, что операционная система обычно читает данные порциями больше, чем размер страницы: с большой вероятностью несколько следующих страниц уже окажутся в кэше операционной системы. 

Последовательное сканирование эффективно работает, когда надо прочитать всю таблицу или значительную ее часть. Если же из всей таблицы нужна только небольшая часть записей, более предпочтительными являются методы доступа, использующие индекс.

```sql
EXPLAIN SELECT * FROM flights;


                           QUERY PLAN                           
----------------------------------------------------------------
Seq Scan on flights  (cost=0.00..4772.67 rows=214867 width=63)
(1 row)
```

* cost — оценка стоимости
* rows — оценка числа строк, возвращаемых операцией
* width — оценка размера одной записи в байтах

Стоимость указывается в некоторых условных единицах и состоит из двух компонент: начальной стоимости вычисления узла и полной стоимости для вычисления всех компонент.


```sql
EXPLAIN SELECT count(*) FROM seats;


                          QUERY PLAN                           
---------------------------------------------------------------
Aggregate  (cost=24.74..24.75 rows=1 width=8)
   ->  Seq Scan on seats  (cost=0.00..21.39 rows=1339 width=0)
(2 rows)
```

План состоит из двух узлов. Верхний - `Aggregate`, в котором происходит вычисление count, он получает данные от нижнего - `Seq Scan`. Узел не может выдать результат, пока не обработает все данные, поэтому начальная стоимость в `Aggregate` практически равна полной.


### Parallel Seq Scan

Параллельное последовательное сканирование - страницы таблицы читаются последовательно, в том же самом порядке, в котором они читались бы при обычном последовательном сканировании. Однако запросы на чтение выдаются несколькими параллельно работающими процессами. Процессы синхронизируются между собой, чтобы их запросы шли в правильном порядке. Преимущество такого сканирования проявляется в том, что параллельные процессы одновременно обрабатывают свои страницы.

Число одновременно выполняющихся рабочих процессов, обслуживающих один ведущий процесс, ограничено параметром `max_parallel_workers_per_gather` (по умолчанию 2).

Планировщик вообще не будет рассматривать параллельное сканирование, если физический размер таблицы меньше значения параметра `min_parallel_table_scan_size`. Например, стандартное значение `min_parallel_table_scan_size` = 8MB:

```sql
SHOW min_parallel_table_scan_size;

 min_parallel_table_scan_size 
------------------------------
 8MB
(1 row)
```

|Размер таблицы|Количество процессов|
|---|---|
|8MB|1|
|24MB|2|
|72MB|3|
|216MB|4|
|648MB|5|
|1.9GB|6|

Число процессов можно и явно указать в параметре хранения `parallel_workers` таблицы.


Не распараллеливаются:
* Запросы, изменяющие или блокирующие данные (UPDATE, DELETE, SELECT FOR UPDATE и т. п.).
* Запросы, выполнение которых может быть приостановлено — это относится к запросам в курсорах, в том числе в циклах FOR PL/pgSQL.
* Запросы, содержащие функции, помеченные как PARALLEL UNSAFE.
* Запросы, содержащиеся в функциях, которые вызываются из распараллеленного запроса


```sql
EXPLAIN SELECT count(*) FROM bookings;


                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Finalize Aggregate  (cost=25442.58..25442.59 rows=1 width=8)
   ->  Gather  (cost=25442.36..25442.57 rows=2 width=8)
         Workers Planned: 2
         ->  Partial Aggregate  (cost=24442.36..24442.37 rows=1 width=8)
               ->  Parallel Seq Scan on bookings  (cost=0.00..22243.29 rows=879629 width=0)
(5 rows)
```

Все, что находится ниже узла Gather — параллельная часть плана. Она выполняется в каждом из рабочих процессов (которых запланировано два) и, возможно, в ведущем процессе. Узел Gather и все узлы выше выполняются только в ведущем процессе. Это последовательная часть плана.

Узел `Gather` и все узлы выше выполняются только в ведущем процессе. Это последовательная часть плана. Далее разбор пойдет снизу вверх по телу плана:

* Узел `Parallel Seq Scan` представляет сканирование таблицы в параллельном режиме. В поле rows показана оценка числа строк, которые обработает один рабочий процесс. Всего их запланировано 2, и еще часть работы выполнит ведущий, поэтому общее число строк делится на 2.4 (доля ведущего процесса уменьшается с ростом числа рабочих процессов). Для оценки узла `Parallel Seq Scan` компонента ввода-вывода берется полностью, а ресурсы процессора делятся между процессами (на 2.4 в данном случае).

* Узел `Partial Aggregate` выполняет агрегацию данных, полученных рабочим процессом, то есть в данном случае подсчитывает количество строк. 

* Узел `Gather` выполняется ведущим процессом. Он отвечает за запуск рабочих процессов и получение от них данных.

* Узел `Finalize Aggregate` агрегирует полученные частичные агрегаты. Поскольку для этого надо сложить всего три числа, оценка минимальна.


##### Пометки параллельности для функций и агрегатов

Для функций существует три типа пометок параллельности:

1. `PARALLEL SAFE` — не препятствует параллельному выполнению запроса;
2. `PARALLEL UNSAFE` — запрещает параллельное выполнение запроса (функция изменяет состояние базы данных, транзакции или конфигурационных параметров), пользовательские функции по умолчанию получают пометку `PARALLEL UNSAFE`.;
3. `PARALLEL RESTRICTED` — запрос может выполняться параллельно, но функция может выполняться только в ведущем процессе (функция обращается к состоянию сеанса: к временным таблицам, курсорам, подготовленным операторам и т. п.).

Функция, отмеченная как безопасная для параллельного выполнения:
```sql
CREATE FUNCTION ticket_amount(ticket_no char(13)) RETURNS numeric
LANGUAGE plpgsql STABLE PARALLEL SAFE
AS $$
BEGIN
    RETURN (SELECT sum(amount)
            FROM ticket_flights tf
            WHERE tf.ticket_no = ticket_amount.ticket_no
    );
END;
$$;
```


### Index Scan

Индексное сканирование - это метод поиска данных, при котором используется индекс, предварительно созданный на колонке таблицы. Индекс позволяет быстро находить нужные данные без необходимости просмотра каждой строки таблицы. 

B-дерево (B-tree) - самый часто применяющийся на практике тип индекса. Особенностями B-дерева является его сбалансированность (постоянная глубина) и сильная ветвистость. Хотя размер дерева зависит от проиндексированных столбцов, на практике деревья обычно имеют глубину не больше 4–5.

```sql
EXPLAIN SELECT * FROM bookings WHERE book_ref = 'CDE08B';


                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Index Scan using bookings_pkey on bookings  (cost=0.43..8.45 rows=1 width=21)
   Index Cond: (book_ref = 'CDE08B'::bpchar)
(2 rows)
```

Выбран метод доступа Index Scan, указано имя использованного индекса. Здесь обращение и к индексу, и к таблице представлено одним узлом плана. Строкой ниже указано условие доступа.

Начальная стоимость индексного доступа — оценка ресурсов для спуска к листовому узлу. Она зависит от количества операций сравнения, которые надо выполнить, и от высоты дерева. При оценке считается, что необходимые страницы окажутся в кеше, и оцениваются только ресурсы процессора: цифра получается небольшой.

Полная стоимость добавляет оценку чтения необходимых листовых страниц индекса и табличных страниц. В данном случае, поскольку индекс уникальный, будет прочитана одна индексная страница и одна табличная. 

В строке `Index Cond` плана указываются только те условия, по которым происходит обращение к индексу или которые могут быть проверены на уровне индекса. Дополнительные условия, которые можно проверить только по таблице, отображаются в отдельной строке `Filter`.


### Parallel Index Scan

Сканирование индекса может выполняться в параллельном режиме. Это происходит в два этапа: сначала ведущий процесс спускается от корня дерева к листовой странице. Затем рабочие процессы выполняют параллельное чтение листовых страниц индекса, двигаясь по указателям. Процесс, прочитавший индексную страницу, выполняет и чтение необходимых табличных страниц. При этом может получиться так, что одну и ту же табличную страницу прочитают несколько процессов. Сама страница будет находиться в буферном кеше в одном экземпляре.

Данные читаются с помощью индекса - узел `Parallel Index Scan` в плане запроса. В остальном план читается так же как при `Parallel Sec Scan`.

Число рабочих процессов выбирается примерно так же, как и в случае последовательного сканирования. Сравнивается объем данных, который предполагается прочитать из индекса (определяемый числом индексных страниц) со значением параметра `min_parallel_index_scan_size` (по умолчанию 512kB). 

Если размер выборки меньше, параллельный план не рассматривается оптимизатором. Например, никогда не будет выполняться параллельно доступ к одному значению - в этом случае просто нечего распараллеливать. 

Если размер выборки достаточно велик, число рабочих процессов определяется по формуле, если только оно не указано явно в параметре хранения `parallel_workers` таблицы (не индекса). Число процессов в любом случае не будет превышать значения параметра `max_parallel_workers_per_gather`.


### Index Only Scan

Если вся необходимая информация содержится в самом индексе, то нет необходимости обращаться к таблице, за исключением проверки видимости.

```sql
EXPLAIN (analyze, costs off, timing off, summary off)
SELECT book_ref FROM bookings WHERE book_ref <= '100000';


                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Only Scan using bookings_pkey on bookings (actual rows=132109 loops=1)
   Index Cond: (book_ref <= '100000'::bpchar)
   Heap Fetches: 0
(3 rows)
```

Строка `Heap Fetches` показывает, сколько версий строк было проверено с помощью таблицы. В данном случае карта видимости содержит актуальную информацию, обращаться к таблице не потребовалось.

Если обновить первую строку таблицы - число версий строк изменится:

```sql
UPDATE bookings
SET total_amount = total_amount
WHERE book_ref = '000004';


EXPLAIN (analyze, costs off, timing off, summary off)
SELECT book_ref FROM bookings WHERE book_ref <= '100000';


                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Index Only Scan using bookings_pkey on bookings (actual rows=132109 loops=1)
   Index Cond: (book_ref <= '100000'::bpchar)
   Heap Fetches: 158
(3 rows)
```


### Include-индексы

Покрывающий индекс (covering index) - это индекс, который содержит все столбцы, необходимые для выполнения запроса, включая столбцы, участвующие в условиях WHERE, а также столбцы, которые возвращаются в результирующем наборе. Такой индекс позволяет выполнить запрос, используя только индексные данные, без необходимости обращения к основной таблице, что делает запрос более эффективным.

Чтобы сделать индекс покрывающим, в него может понадобиться добавить столбцы, но это не всегда возможно:
* Добавление столбца в уникальный индекс нарушит гарантию уникальности исходных столбцов;
* Тип данных добавляемого столбца может не поддерживаться индексом.

В таких случаях можно добавить к индексу неключевые столбцы, указав их в предложении `INCLUDE`.

```sql
CREATE INDEX ... INCLUDE (...)
```

Значения таких столбцов не формируют дерево индекса, а просто хранятся как дополнительные сведения в индексных записях листовых страниц. Поиск по неключевым столбцам не работает, но их значения могут возвращаться без обращения к таблице.

В include-индекс можно включать столбцы с типами данных, которые не поддерживаются B-деревом (например, геометрические типы и xml).


### Parallel Index Only Scan

Сканирование только индекса может выполняться параллельно. Это происходит точно так же, как и при обычном индексном сканировании: ведущий процесс спускается от корня к листовой странице, а затем рабочие процессы параллельно сканируют листовые страницы индекса, обращаясь при необходимости к соответствующим страницам таблицы для проверки видимости.


### Исключение дубликатов (практический пример)

Сначала создадим индекс, отключив исключение дубликатов с помощью параметра хранения deduplicate_items, затем посмотрим размер созданного индекса:
```sql
CREATE INDEX dedup_test ON ticket_flights (fare_conditions) 
WITH (deduplicate_items = off);

SELECT pg_size_pretty(pg_total_relation_size('dedup_test'));

 pg_size_pretty 
----------------
 187 MB
(1 row)
```

Выполним запрос с помощью индекса, отключив для этого последовательное сканирование. Нужно обратить внимание на время выполнения запроса.

```sql
SET enable_seqscan = off;

EXPLAIN (analyze, buffers, costs off) SELECT fare_conditions FROM ticket_flights;


                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Only Scan using dedup_test on ticket_flights (actual time=0.034..730.144 rows=8391852 loops=1)
   Heap Fetches: 0
   Buffers: shared hit=4 read=23877
 Planning:
   Buffers: shared hit=21 read=2
 Planning Time: 1.093 ms
 Execution Time: 979.735 ms
(7 rows)
```

Это результаты запроса при настройках, допускающих наличие дубликатов. Теперь пересоздадим индекс без параметра `deduplicate_items`, он по-умолчанию включен:

```sql
DROP INDEX dedup_test;

CREATE INDEX dedup_test ON ticket_flights (fare_conditions);

SELECT pg_size_pretty(pg_total_relation_size('dedup_test'));

 pg_size_pretty 
----------------
 56 MB
(1 row)

EXPLAIN (analyze, buffers, costs off) 
SELECT fare_conditions FROM ticket_flights;


                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Index Only Scan using dedup_test on ticket_flights (actual time=0.022..490.932 rows=8391852 loops=1)
   Heap Fetches: 0
   Buffers: shared hit=5 read=7077
 Planning:
   Buffers: shared hit=5 read=1
 Planning Time: 0.083 ms
 Execution Time: 724.389 ms
(7 rows)
```

Исключение дубликатов сократило размер индекса более, чем в три раза, а также сократило время выполнения запроса.


### Bitmap Index Scan

<em>Битовая карта (Bitmap) - это структура данных, которая представляет собой последовательность битов, используемая для хранения информации о присутствии или отсутствии элементов набора данных. Каждый бит в битовой карте соответствует определенному элементу или полю данных, и его значение указывает, присутствует ли данный элемент или поле.</em>

При использовании Bitmap Index Scan PostgreSQL создает битовую карту для каждого условия запроса, а затем объединяет их в одну битовую карту, которая указывает на строки, которые удовлетворяют всем условиям запроса. Затем эти строки считываются из таблицы.

Bitmap Index Scan хорошо работает для запросов, которые содержат множество условий, так как он позволяет эффективно объединять результаты различных индексов. Однако при работе с большими объемами данных и сложными запросами может возникнуть дополнительная нагрузка на память и процессор.

Этот метод сканирования может быть особенно полезен в случаях, когда стоит задача выполнения запросов с использованием сложных логических операций и условий, таких как `AND`, `OR` или `NOT`.

```sql
EXPLAIN SELECT * FROM bookings WHERE total_amount < 10000;


                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Bitmap Heap Scan on bookings  (cost=1145.71..15356.08 rows=61069 width=21)
   Recheck Cond: (total_amount < '10000'::numeric)
   ->  Bitmap Index Scan on bookings_total_amount_idx  (cost=0.00..1130.45 rows=61069 width=0)
         Index Cond: (total_amount < '10000'::numeric)
(4 rows)
```

Метод доступа Bitmap Scan состоит из двух узлов:

* Bitmap Index Scan читает индекс и строит битовую карту;
* Bitmap Heap Scan читает табличные страницы, используя построенную карту.


### Parallel Bitmap Heap Scan

Сканирование по битовой карте может выполняться параллельно. 
Первый этап — <b>сканирование индекса</b> — всегда выполняется последовательно ведущим процессом. 
Второй этап — <b>сканирование таблицы</b> — выполняется рабочими процессами параллельно. Это происходит аналогично параллельному последовательному сканированию.

```sql
SELECT bookings.now() - INTERVAL '1 months' AS d

EXPLAIN (costs off) 
SELECT count(*) 
FROM bookings 
WHERE total_amount < 20000 AND book_date > :'d';


                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Finalize Aggregate
   ->  Gather
         Workers Planned: 2
         ->  Partial Aggregate
               ->  Parallel Bitmap Heap Scan on bookings
                     Recheck Cond: (book_date > '2017-07-15 18:00:00+03'::timestamp with time zone)
                     Filter: (total_amount < '20000'::numeric)
                     ->  Bitmap Index Scan on bookings_book_date_idx
                           Index Cond: (book_date > '2017-07-15 18:00:00+03'::timestamp with time zone)
(9 rows)
```

Узел `Bitmap Index Scan` выполняется ведущим процессом, который строит битовую карту. Параллельно выполняется только сканирование таблицы по уже готовой битовой карте — узел `Parallel Bitmap Heap Scan`.


### Сравнение эффективности 

<b>Индексное сканирование</b> лучше всего работает при очень высокой селективности (селективность индекса - характеристика, определяющая, насколько эффективно индекс разбивает данные), когда по индексу выбирается одно или несколько значений. 

При средней селективности лучше всего показывает себя <b>сканирование по битовой карте</b>. Оно работает лучше индексного сканирования, поскольку обходится без повторных чтений одних и тех же страниц. Однако при сканировании по битовой карте возникают накладные расходы на построение карты, поэтому при высокой селективности оно проигрывает. 

При низкой селективности лучше всего работает <b>последовательное сканирование</b>: если надо выбрать все или почти все табличные строки, обращение к индексным страницам только увеличивает накладные расходы. Этот эффект усиливается в случае вращающихся дисков, где стоимость произвольного чтения существенно выше стоимости чтения последовательно расположенных страниц. 

Значение селективности, при котором становится выгодно переключиться на другой метод доступа, сильно зависит от конкретной таблицы и конкретного индекса. Планировщик учитывает множество параметров, чтобы выбрать наиболее подходящий способ.

<b>Sequential Scan (Sec Scan)</b> - этот метод сканирования просматривает таблицу последовательно, без учета индексов. Он может быть эффективен для сканирования небольших таблиц или при отсутствии подходящих индексов.

<b>Parallel Sequential Scan (Parallel Sec Scan)</b> - данный метод позволяет распараллеливать выполнение `Sec Scan` на несколько ядер процессора, ускоряя выполнение запроса в случае наличия многопроцессорной системы.

<b>Index Scan</b> - данный метод использует индекс для поиска конкретных значений в таблице. Он может быть эффективен при поиске конкретных строк в таблице.

<b>Parallel Index Scan</b> - аналогично `Parallel Sec Scan`, этот метод позволяет распараллеливать выполнение Index Scan на несколько ядер процессора.

<b>Index Only Scan</b> - данный метод использует только индекс для выполнения запроса, без необходимости просмотра данных в таблице. Это может ускорить выполнение запроса в случае, если в индексе содержатся все необходимые данные.

<b>Parallel Index Only Scan</b> - аналогично `Parallel Sec Scan`, этот метод позволяет распараллеливать выполнение Index Only Scan на несколько ядер процессора.

<b>Bitmap Index Scan</b> - данный метод использует битовые индексы для выполнения запроса. Он может быть эффективен при поиске значений с использованием нескольких индексов.

<b>Parallel Bitmap Index Scan</b> - этот метод позволяет распараллеливать выполнение `Bitmap Index Scan` на несколько ядер процессора.

Для выбора наиболее эффективного метода сканирования необходимо провести тестирование на конкретных данных и запросах, чтобы определить, какой метод работает лучше для данной ситуации. Обычно, <em>Index Scan, Index Only Scan и Parallel Index Scan</em> оказываются наиболее эффективными методами сканирования в PostgreSQL. Однако, стоит учитывать, что оптимальный метод может зависеть от многих факторов, таких как размер таблицы, объем данных, структура индексов и распределение данных.


### Кластеризация

Если строки таблицы упорядочены так же, как и индекс, битовая карта становится излишней. 

Команда `CLUSTER` в PostgreSQL используется для переупорядочивания данных в таблице на основе заданного индекса. Это позволяет улучшить производительность запросов к таблице, так как данные становятся упорядоченными и ближе к индексам, что ускоряет выполнение запросов. При этом физически данные в таблице не перемещаются, а лишь переупорядочиваются на диске.  Однако, использование команды `CLUSTER` может занять некоторое время и во время выполнения данной операции таблица будет заблокирована для записи.

```sql
CLUSTER bookings USING bookings_total_amount_idx;
```
... где bookings - таблица, а bookings_total_amount_idx - индекс.


### Nested Loop

Nested Loop - это метод сканирования, который используется для выполнения соединения двух таблиц.

При использовании Nested Loop, выбирается одна таблица как внутренняя, а вторая как внешняя. Затем для каждой записи из внешней таблицы PostgreSQL сканирует все записи внутренней таблицы, чтобы найти все соответствующие записи.

Этот метод эффективен в случае, когда одна из таблиц небольшая или когда существует индекс, который можно использовать для ускорения поиска записей.

Однако, если обе таблицы имеют большое количество записей, Nested Loop может быть неэффективным по производительности, так как он требует сканирования каждой записи внешней таблицы для каждой записи внутренней таблицы.