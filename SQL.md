# Structured Query Language

### Команды SQL

* <b>DDL - язык определения данных (Data Definition Language)</b>

|Команда|Описание|
|---|---|
|CREATE|Создать объект базы данных|
|ALTER|Модифицировать существующий объект базы данных|
|DROP|Удалить существующий объект базы данных|


* <b>DML - язык изменения данных (Data Manipulation Language)</b>

|Команда|Описание|
|---|---|
|SELECT|Извлечь записи из таблицы|
|INSERT|Создать записи|
|UPDATE|Изменить записи|
|DELETE|Удалить записи|


* <b>DCL - язык управления данными (Data Control Language)</b>

|Команда|Описание|
|---|---|
|GRANT|Наделить пользователя правами|
|REVOKE|Отменить права пользователя|


### Базовые конструкции SQL

##### *
Вывести все колонки из таблицы products:
```sql
SELECT * FROM products;
```

##### Подсчет количества строк в колонке
Вывести количество записей в таблице products:
```sql
SELECT COUNT(*) FROM products;
```

##### Несколько колонок
Вывести колонки product_name и unit_price из таблицы products:
```sql
SELECT product_name, unit_price FROM products;
```

##### Исключение дубликатов
Вывести данные без повторений из колонки unit_price таблицы products:
```sql
SELECT DISTINCT unit_price FROM products;
```

##### WHERE, OFFSET, LIMIT
Вывести product_name из products, где discontinued равен 0, записи с 5 по 10:
```sql
SELECT product_name FROM products WHERE discontinued = 0 OFFSET 5 LIMIT 10;
```

##### IN
Вывести те записи product_name из products, в которых reorder_level равен одному из значений, указанных в скобках:
```sql
SELECT product_name FROM products WHERE reorder_level IN (25, 15);
```

##### BEETWEEN ... AND ...
Вывести данные из колонок order_date и order_id из таблицы orders, где order_date находится в пределах от '1997-01-01' до '1998-01-01':
```sql
SELECT order_date, order_id FROM orders WHERE order_date BETWEEN '1997-01-01' AND '1998-01-01';
```

##### Выборка по совпадениям
Вывести те данные из customer_id и company_name из таблицы customers, где в названии customers_id в середине присутствует символ 'A':

('%A' - если customer_id оканчивается на 'A', 'A%'- если customer_id начинается на 'A')
```sql
SELECT customer_id, company_name FROM customers WHERE customer_id LIKE '%A%';
```

##### Переименование колонок
Вывести данные company_name, переименовав колонку в com_name:
```sql
SELECT company_name AS com_name FROM customers;
```

##### Максимальное значение
Вывести максимальное значение unit_price из таблицы order_details:
```sql
SELECT MAX(unit_price) FROM order_details;
```

##### Округление, среднее значение
Вывести округленное среднее число unit_price из таблицы order_details:
```sql
SELECT ROUND(AVG(unit_price)) FROM order_details;
```

##### Арифметика в запросе
Вывести округленное произведение значений колонок unit_price и quantity и поместить полученные значения в колонку, названную res_values:
```sql
SELECT ROUND(unit_price * quantity) AS res_value FROM order_details;
```

##### НЕ
Вывести значения order_id и discount из order_details, которые НЕ равны 0: 
```sql
SELECT order_id, discount FROM order_details WHERE discount <> 0;
```

##### Обратный порядок
Вывести customer_id и order_date из таблицы orders, где значения отсортированы по колонке order_date В ОБРАТНОМ ПОРЯДКЕ:
```sql
SELECT customer_id, order_date FROM orders ORDER BY order_date DESC;
```

##### Группировка данных
Вывести общее количество записей колонки country из таблицы employees, сгруппировав результат по колонке country (количество каждой из country):
```sql
SELECT country, COUNT(*) FROM employees GROUP BY country;
```

##### Фильтрация результатов
Вывести category_id и сумму произведений unit_price и units_in_stock в таблице products, сгруппировав результаты по category_id (сколько суммарно вышло sum_price на каждый category_id) и отфильтровав результаты (вывести только те category_id), где SUM(unit_price * units_in_stock) больше 5000:

(работает в сочетании с GROUP BY)
```sql
SELECT category_id, SUM(unit_price * units_in_stock) AS sum_price
FROM products
GROUP BY category_id
HAVING SUM(unit_price * units_in_stock) > 5000;
```

##### Объединение
Вывести country из таблицы employees, country из таблицы customers и объединить результаты в одну колонку:

(UNION устраняет дубликаты, UNION ALL выводит результат с дубликатами)
```sql
SELECT country FROM employees
UNION
SELECT country FROM customers;
```

##### Пересечение
Вывести country, совпадающие для customers и suppliers:
```sql
SELECT country FROM customers
INTERSECT
SELECT country FROM suppliers;
```

##### Исключение
Вывести country из таблицы customers, которых нет в country таблицы suppliers:
```sql
SELECT country FROM customers
EXCEPT
SELECT country FROM suppliers;
```

##### Соединение
<b>INNER JOIN</b> 
Вывести product_name и units_in_stock из products и company_name из suppliers, левая таблица - products, правая - suppliers, соединить их по колонке supplier_id, одинаковой для обеих таблиц:

(для таблицы products колонка supplier_id является внешним ключом)

<em>Соединение таблиц происходит по внешнему ключу, далее выбираются колонки, которые необходимо вывести из обеих таблиц.</em>

```sql
SELECT products.product_name, suppliers.company_name, products.units_in_stock
FROM products
INNER JOIN suppliers ON products.supplier_id = suppliers.supplier_id;
```

<b>LEFT / RIGHT JOIN</b>
Вывести количество записей из таблицы employees и объединить с таблицей orders по внешнему ключу employee_id:

(LEFT JOIN выведет все данные из левой таблицы и только совпадающие из правой. RIGHT JOIN работает обратным образом)

```sql
SELECT COUNT(*)
FROM employees
LEFT JOIN orders ON orders.employee_id = employees.employee_id;
```

##### Синтаксические конструкции USING и NATURAL при соединениях

<b>USING</b> берет наименование колонки, одинаковое для двух таблиц, по которой идет соединение.

<b>NATURAL</b> соединение происходит по всем одинаково проименованным колонкам.

```sql
INNER JOIN suppliers ON products.supplier_id = suppliers.supplier_id;

-- или

JOIN suppliers USING(supplier_id)

-- или

NATURAL JOIN suppliers
```

##### Подзапросы
Вывести те company_name из suppliers, country которых есть среди country из таблицы customers:

(Подзапросы часто можно заменить соединениями таблиц, но это возможно не всегда, а когда возможно, нужно ориентироваться на производительность запросов и их читабельность)
```sql
SELECT company_name
FROM suppliers
WHERE country IN (SELECT country
                FROM customers)
```

<b>WHERE EXISTS</b>
Вывести company_name и contact_name из customers, если соблюдено условие в подзапросе (Вывести customer_id из orders, где customer_id в таблицах orders и customers совпадает, и где freight находится в заданном диапазоне):

(EXISTS (или NOT EXISTS) возвращает True или False. Если True, то внешний запрос выводит выборку данных, если False то данных нет)

```sql
SELECT company_name, contact_name
FROM customers
WHERE EXISTS (SELECT customer_id
            FROM orders
            WHERE customer_id = customers.customer_id
            AND freight BETWEEN 50 AND 100)
```

<b>ANY / ALL</b>
Вывести company_name из customers, где customer_id равен НЕКОТОРЫМ из выборки в подзапросе (вывести customer_id из orders, соединив таблицы orders и order_details по order_id, где quantity больше 40):

(ANY - некоторые, ALL - все)

```sql
SELECT company_name
FROM customers
WHERE customer_id = ANY(SELECT customer_id
                        FROM orders
                        JOIN order_details USING(order_id)
                        WHERE quantity > 40)
```


### DDL (Data Difinition Language)

`CREATE TABLE table_name`   создать таблицу

`ALTER TABLE table_name`    изменить таблицу
    * `ADD COLUMN column_name data_type`  изменить колонку (с типом данных)
    * `RENAME TO new_table_name`     переименовать таблицу
    * `RENAME old_column_name TO new_column_name`   переименовать колонку
    * `ALTER COLUMN column_name SET DAtA TYPE data_type`    задать новый тип данных для колонки

`DROP TABLE table_name`    удалить таблицу

`TRUNCATE TABLE table_name`     очистить таблицу от данных

`DROP COLUMN column_name`       удалить колонку   


Изменить таблицу и добавить в нее внешний ключ:

(ключевое слово ONLY прямо указывает, что изменения относятся только к указанной таблице)
```sql
ALTER TABLE ONLY orders
    ADD CONSTRAINT fk_orders_customers FOREIGN KEY (customer_id) REFERENCES customers;
```

Изменить таблицу и назначить для атрибута PRIMARY KEY:
```sql
ALTER TABLE ONLY categories
    ADD CONSTRAINT pk_categories PRIMARY KEY (category_id);
```

Изменить таблицу, добавить условие CHECK для атрибута:
```sql
ALTER TABLE product
    ADD COLUMN price DECIMAL CONSTRAINT CHK_product_price CHECK (price >= 0);
```

##### Автоинкремент
В PostgreSQL более ранних версий, чем 9 в качестве автоинкремента используется тип SERIAL. В последних версиях наиболее предпочтительна следующая конструкция:

```sql
CREATE TABLE new_table
(
    column_id INT GENERATED ALWAYS AS IDENTITY (START WITH 0 INCREMENT BY 1) NOT NULL
);
```

##### UPDATE
Изменить в таблице table_name в колонке column_name атрибут с id 5:
```sql
UPDATE table_name
SET column_name
WHERE id = 5;
```

##### DELETE
Удалить из таблицы table_name данные, где rating < 50:
```sql
DELETE FROM table_name
WHERE rating < 50;
``` 

##### RETURNING

Оператор `RETURNING` используется для получения значений после выполнения операции `INSERT`, `UPDATE` или `DELETE`. Он позволяет вернуть значения измененных столбцов или вычисленные значения после выполнения операции.

Например, если нужно вставить новую хапись в таблицу и получить значение автоматически сгенерированного идентификатора (например, ID), можно использовать оператор `RETURNING`:

```sql
INSERT INTO employees (name, department)
VALUES ('John Doe', 'HR')
RETURNING id;
```

В данном примере после выполнения оператора `INSERT` в таблицу employees будет вставлена новая запись с именем "John Doe" и отделом "HR". Оператор `RETURNING` вернет сгенерированный идентификатор (ID) этой записи.

Оператор `RETURNING` также может быть полезен при выполнении операций обновления (`UPDATE`) или удаления (`DELETE`), позволяя получить значения измененных столбцов или выполнить дополнительные действия на основе этих значений.


### Временные таблицы

Временные таблицы в SQL - это таблицы, которые создаются и существуют только в течение текущей сессии или до конца выполнения запроса. Они могут быть созданы с помощью ключевого слова `CREATE TEMPORARY TABLE` или просто `CREATE TABLE` с указанием ключевого слова `TEMPORARY`.

Временные таблицы могут использоваться для временного хранения данных во время выполнения сложных запросов, для временного хранения результатов промежуточных вычислений, для создания временного хранилища данных для преобразования данных и т.д.

```sql
CREATE TEMPORARY TABLE temp_table (
    id INT,
    name VARCHAR(50),
    age INT
);

INSERT INTO temp_table (id, name, age) VALUES (1, 'Alice', 25);
INSERT INTO temp_table (id, name, age) VALUES (2, 'Bob', 30);

SELECT * FROM temp_table;

DROP TABLE temp_table;
```

В данном примере создается временная таблица <b>temp_table</b> с тремя колонками (id, name, age), затем в нее добавляются две записи. После этого выполняется запрос на выбор всех данных из временной таблицы <b>temp_table</b>. В конце сеанса сессии временная таблица будет автоматически удалена с помощью команды `DROP TABLE`.


### Представление (VIEW)

VIEW (представление) - это виртуальная таблица, созданная на основе одной или нескольких таблиц в базе данных. Представление не содержит собственных данных, оно является логическим представлением данных из одной или нескольких таблиц и сохраняет результат запроса в виде временной или постоянной таблицы.

Представления используются для упрощения запросов к данным. Они позволяют пользователю или приложению работать с данными, не зная сложности запросов или структуры базы данных. 

Преимущества использования представлений:
1. Упрощение сложных запросов: Представления позволяют объединять и фильтровать данные из разных таблиц в один запрос, тем самым упрощая запросы для конечных пользователей.
2. Обеспечение безопасности данных: Представления могут служить фильтрами, ограничивающим доступ к определенным данным или столбцам.
3. Повторное использование запросов: Представления могут быть переиспользованы в различных частях приложения или запросах.
4. Упрощение разработки и обслуживания: Представления позволяют разработчикам абстрагироваться от сложности базы данных и сосредоточиться на запросах и бизнес-логике.

Чтобы создать представление, используется оператор <b>CREATE VIEW</b>, который определяет имя представления, выбирает столбцы и условия для фильтрации данных. Затем представление может быть использовано в запросах, как обычная таблица.

Пример создания представления:
```sql
CREATE VIEW myview AS
SELECT column1, column2
FROM table_name;
```

После создания представления можно использовать его в запросах:
```sql
SELECT * FROM myview;
```

Ограничения, налагаемые на VIEW:

* Можно только добавлять новые колонки,
    * нельзя удалить существующие,
    * нельзя переименовывать колонки,
    * нельзя менять порядок следования колонок
* Можно переименовывать сами VIEW

Чтобы была возможность вносить изменения во VIEW, вместо <b>CREATE VIEW</b> нужно прописывать <b>CREATE OR REPLACE VIEW</b>.

Условия для модификации данных через VIEW:
* Во VIEW используется только одна таблица в секции FROM,
* Во VIEW не используется DISTINCT, GROUP BY, HAVING, UNION, INTERSECT, EXCEPT, LIMIT
* Во VIEW не используются оконные функции MIN, MAX, SUM, COUNT, AVG


### MATERIALIZED VIEW

`MATERIALIZED VIEW` в SQL - это предварительно вычисленное представление данных, которое хранится на диске как обычная таблица. Оно может использоваться для ускорения процесса выполнения запросов, так как данные в materialized view уже предварительно вычислены и индексированы.

`MATERIALIZED VIEW` могут быть полезны в следующих случаях:
- Когда требуется часто выполнять тяжелые запросы, которые замедляют работу системы. `MATERIALIZED VIEW` позволяет сохранить результат запроса и обновлять его только при необходимости.
- При наличии больших объемов данных, которые часто запрашиваются, чтобы уменьшить время выполнения запросов.
- При необходимости предварительно вычисленных агрегатов для отчетов или аналитики.

Подсчета общего количества заказов для каждого клиента:
```sql
CREATE MATERIALIZED VIEW customer_order_count AS
SELECT customer_id, COUNT(order_id) AS order_count
FROM orders
GROUP BY customer_id;
```

Обновление данных:
```sql
REFRESH MATERIALIZED VIEW customer_order_count;
```

Использование в запросе:
```sql
SELECT *
FROM customer_order_count
WHERE customer_id = 123;
```

В данном примере customer_order_count хранит общее количество заказов для каждого клиента. При необходимости данные в `MATERIALIZED VIEW` можно обновить с помощью команды `REFRESH`, чтобы отразить последние изменения в базе данных.

Основное отличие между `MATERIALIZED VIEW` и обычными `VIEW` (виртуальными представлениями) заключается в том, что `MATERIALIZED VIEW` хранит результат запроса на диске как физическую таблицу, в то время как обычный `VIEW` просто сохраняет определение запроса и выполняет его динамически при обращении к нему.

Основные различия:

1. Хранение данных:
   - `MATERIALIZED VIEW` хранит реальные данные на диске, что позволяет уменьшить время выполнения запросов за счет предварительного вычисления и индексирования данных.
   - `VIEW` не хранит данные физически, он просто сохраняет определение запроса, и каждый раз запрос будет выполняться заново при обращении к нему.

2. Операции обновления:
   - Данные в `MATERIALIZED VIEW` может быть обновлен вручную или автоматически с использованием триггеров или планировщиков задач.
   - Обычный `VIEW` всегда дает актуальные данные из базовых таблиц, поскольку запрос выполняется динамически при обращении.

3. Затраты на обновление данных:
   - `MATERIALIZED VIEW` требует дополнительных затрат на обновление данных, но ускоряет выполнение запросов за счет предварительного вычисления.
   - Обычный `VIEW` не требует затрат на хранение данных, однако может быть медленным при выполнении сложных запросов из-за частого выполнения запроса на базовые таблицы.

Таким образом, `MATERIALIZED VIEW` обычно используются для оптимизации производительности системы путем предварительного вычисления и хранения данных, в то время как обычные `VIEW` обеспечивают динамическое представление данных из базовых таблиц.


### CASE / WHEN

Вывести product_name, unit_price, unit_in_stock из таблицы products, и в зависимости от поставленных условий, в отдельную колонку amount выводить текстовые сообщения 'lots of', 'average' и 'low number':
```sql
SELECT product_name, unit_price, unit_in_stock
    CASE WHEN unit_in_stock >= 100 THEN 'lots of'
         WHEN unit_in_stock > 50 AND unit_in_stock < 100 THEN 'average'
         WHEN unit_in_stock < 50 THEN 'low number'
         ELSE 'unknown'
    END AS amount
FROM products;
```


### COALESCE

Вывести order_id, order_date и обработанную колонку ship_region таким образом, что будут отображены значения не NULL, а значения NULL будут заменены строкой 'нет данных';
```sql
SELECT order_id, order_date, COALESCE(ship_region, 'нет данных') AS ship_region
FROM orders;
```


### Массивы

Массивы - это структуры данных, которые позволяют хранить несколько значений в одной переменной. Они могут быть использованы для хранения списков, наборов объектов или других типов данных.

<b>В SQL</b> массивы могут быть определены с помощью квадратных скобок []. Например: 

```sql
CREATE TABLE my_table (id INT, my_array INT[]);
``` 

Затем можно вставить значения в массив следующим образом: 

```sql
INSERT INTO my_table (id, my_array) VALUES (1, '{1,2,3}');
```

Для доступа к элементам массива использестся индексация - my_array[1] вернет первый элемент массива.


<b>В PL/pgSQL</b>, можно создать массивы с помощью оператора `ARRAY []`. Например, `my_array := ARRAY[1,2,3]`. Для доступа к элементам массива используется оператор []. Например, my_array[1] вернет первый элемент массива.

Массивы могут быть использованы в SQL и PL/pgSQL для хранения списков значений, фиксированных наборов объектов или для выполнения операций над наборами данных. Они удобны для работы с наборами данных, например, если нужно хранить список id пользователей, список заказов или другие списки данных.

Основные операции над массивами в SQL и PL/pgSQL включают добавление или удаление элементов, доступ к элементам массива, выполнение операций над всеми элементами массива и преобразование массивов в другие типы данных.

В целом, массивы в SQL и PL/pgSQL предоставляют удобный способ хранения и обработки списков данных. Они могут быть использованы для различных целей, включая хранение списков, фильтрацию данных, выполнение операций над множествами и многое другое.


### Функции

* SQL-функции
* Процедурные (pl/pgSQL функции)
* Серверные функции (написанные на C)
* Собственные C-функции

Простая скалярная функция
```sql
-- Синтаксис функции
CREATE OR REPLACE FUNCTION total_price() RETURNS DOUBLE PRECISION AS $$
	SELECT SUM(unit_price * units_in_stock) AS total
	FROM products
$$ LANGUAGE SQL;

-- Вызов функции
SELECT total_price() AS total_price_products;
```

Функция с аргументами
```sql
CREATE OR REPLACE FUNCTION get_product_price_by_name(prod_name VARCHAR) RETURNS DOUBLE PRECISION AS $$
	SELECT unit_price
	FROM products
	WHERE product_name = prod_name
$$ LANGUAGE SQL;
```

Функция без имени аргумента
```sql
CREATE OR REPLACE FUNCTION get_hello(TEXT) RETURNS TEXT AS $$
    SELECT 'Hello' || $1 || '!';     -- номер вместо имени
$$ LANGUAGE SQL;

SELECT get_hello('world');
```

Метки "чистоты" функций:
1. <b>IMMUTABLE</b>: Функция всегда возвращает одинаковый результат, если ей передаются одинаковые аргументы, и результат не зависит от состояния базы данных.
2. <b>STABLE</b>: Функция всегда возвращает одинаковый результат для одних и тех же аргументов в пределах одного оператора SQL. Результат может меняться между выполнением разных операторов SQL в одной транзакции.
3. <b>VOLATILE</b>: Функция может вернуть разные результаты для одинаковых аргументов, так как результат зависит от состояния базы данных или внешних вызовов.
4. Составные: Комбинация вышеупомянутых значений, например, STABLE в зависимости от аргументов и IMMUTABLE при равных аргументах.

Эти метки "чистоты" помогают оптимизатору запросов принимать решения о порядке выполнения функций и кэшировании результатов, так как он может предполагать стабильность результата для функций с соответствующими метками.

Например, если функция помечена как IMMUTABLE, то ее результат можно кэшировать, так как будут одинаковые результаты для одинаковых аргументов, что ускорит выполнение запросов.


### Оконные функции

Оконные функции в PostgreSQL позволяют выполнять агрегатные функции (например, суммирование, подсчет, нахождение минимума или максимума) по определенной группе строк, называемой окном. Оконные функции позволяют работать с наборами данных более гибко и эффективно, чем обычные агрегатные функции.

```sql
SELECT column1, column2, aggregate_function(column3) 
OVER (PARTITION BY column4 ORDER BY column5)
FROM table_name;
```

Где:

* column1, column2 - столбцы, которые нужно вернуть в результате запроса
* aggregate_function - агрегатная функция, которуюнужно применить к окну данных
* column3 - столбец, к которому будет применена агрегатная функция
* PARTITION BY - определяет, как разделить данные на группы для вычисления агрегатов
* ORDER BY - определяет порядок строк внутри каждой группы

Допустим, у нас есть таблица "sales" с данными о продажах:

```sql
CREATE TABLE sales 
(
    id serial PRIMARY KEY,
    product_name VARCHAR(50),
    sale_date DATE,
    amount INTEGER
);

INSERT INTO sales (product_name, sale_date, amount) VALUES 
('Product A', '2022-01-01', 100),
('Product B', '2022-01-02', 200),
('Product B', '2022-01-07', 300),
('Product A', '2022-01-03', 120);
```

Теперь нужно найти суммарное количество продаж по каждому продукту на каждую дату:

```sql
SELECT 
    product_name, 
    sale_date, 
    amount,
    SUM(amount) OVER (PARTITION BY product_name ORDER BY sale_date) AS total_sales
FROM sales
ORDER BY product_name, sale_date;
```

В результате выполнения данного запроса получается таблицаё, где для каждого продукта и даты будут показаны суммарное количество продаж и общее количество продаж.




### Процедуры

Хранимые процедуры в SQL — это подготовленные и написанные на SQL операции, которые можно сохранить в базе данных для последующего вызова и повторного использования. Они позволяют группировать несколько операторов SQL вместе и создавать логику обработки данных.

Преимущества использования хранимых процедур:
1. Использование хранимых процедур снижает объем передаваемого по сети трафика, так как запрос к процедуре отправляется один раз, а не в виде множества SQL запросов.
2. Повышение производительности, так как хранимые процедуры могут выполняться быстрее, чем эквивалентные им запросы на стороне клиента.
3. Увеличение безопасности, так как хранимые процедуры могут контролировать доступ к данным и обеспечивать более строгую проверку прав доступа.

Процедуры и функции в SQL имеют ряд существенных различий. Вот основные отличия между ними:

1. <b>Возвращаемое значение</b>: 
   - Функции обязаны вернуть значение, тогда как процедуры не обязаны возвращать результат.

2. <b>Использование в запросах</b>:
   - Функции могут использоваться внутри SQL запросов, также как и обычные столбцы, в то время как процедуры вызываются как отдельные блоки программного кода.

3. <b>Транзакции</b>:
   - Вызов функции в рамках SQL запроса выполняется в рамках той же транзакции, в то время как процедуры могут выполняться в собственной транзакции.

4. <b>Доступные операции</b>:
   - Функции могут выполнять операции записи данных, но обычно используются для чтения и возврата результатов.
   - Процедуры могут включать в себя операции изменения данных (INSERT, UPDATE, DELETE) и они не обязаны возвращать результат.

5. <b>Параметры</b>:
   - Как процедуры, так и функции могут принимать параметры.

6. <b>Использование RETURN</b>:
   - Функции используют оператор RETURN, чтобы вернуть результат.
   - Процедуры не используют RETURN для возврата результата.

Функции обычно используются для выполнения расчетов и возврата результатов, тогда как процедуры используются для выполнения операций по изменению данных или выполнения определенной логики без необходимости возвращать результат.

Пример:
```sql
CREATE TABLE t(TEXT);

CREATE PROCEDURE any_action(row INTEGER) AS $$
    TRUNCATE t;
    INSERT INTO t SELECT random() FROM generate_series(1, row);
$$ LANGUAGE SQL;

CALL any_action(row => 1000);
```


### Индексы

Индексы используются для ускорения поиска, сортировки и фильтрации данных в таблицах. Они создаются на одном или нескольких столбцах таблицы и хранят отсортированные значения для эффективного доступа.

В PostgreSQL существует несколько типов индексов:

1. <b>B-дерево (B-tree)</b> - это самый распространенный тип индекса в PostgreSQL. Он хранит отсортированные значения ключей и обеспечивает быстрый поиск данных.
    
    * Создается по-умолчанию;
    ```sql
    CREATE INDEX idx_time ON btcusdt (curr_time);
    ```

    * Поддерживает операции >, <, <=, >=, =;

    * Поддерживает LIKE 'abc%' (но не '%abc');

    * Индексирует NULL;

    * Сложность поиска O(logN);


2. <b>Хэш-индекс (Hash index)</b> - используется для эффективного поиска точных значений ключа. Он создается на основе хэш-функции, что позволяет быстро найти соответствующую запись.
 
    ```sql
    CREATE INDEX idx_time ON btcusdt USING HASH (curr_time);
    ```

    * Поддерживает только операцию  '=';

    * Не отражается в журнале предзиписи (WALL);

    * Сложность поиска O(1) (мгновенно);


3. <b>GIN (Generalized Inverted Index)</b> - используется для полнотекстового поиска и поиска с использованием массивов и других сложных типов данных.

4. <b>GiST (Generalized Search Tree)</b> - обеспечивает поддержку различных типов поиска, таких как географический, полнотекстовый, поиск с учетом расстояния между объектами и многих других.

5. <b>SP-GiST (Space-Partitioned GiST)</b> - обеспечивает эффективный поиск и пространственную индексацию для ключей, связанных с пространственными объектами.

6. <b>BRIN (Block Range INdex)</b> - позволяет быстро и компактно находить блоки записей, которые удовлетворяют условию поиска в больших таблицах.

Для создания индекса используется команда CREATE INDEX. Например, чтобы создать B-дерево индекс на столбце "name" в таблице "users", можно использовать следующий SQL-запрос:

```sql
CREATE INDEX idx_users_name ON users(name);
```

Использование правильных индексов может значительно улучшить производительность запросов в базе данных. Однако, следует быть осторожными с созданием слишком большого количества индексов, так как это может привести к увеличению времени на обновление данных.


### <b>EXPLAIN</b>

Команда <b>EXPLAIN</b> в PostgreSQL используется для анализа и оптимизации выполнения запросов. При использовании команды <b>EXPLAIN</b> перед запросом, PostgreSQL предоставляет информацию о плане выполнения запроса, включая порядок выполнения операций, использование индексов, стоимость операций и другую полезную информацию.

Результат выполнения команды <b>EXPLAIN</b> представляет собой таблицу или дерево, которое обозначает порядок выполнения операций в запросе. Это дает возможность анализировать и понимать, как PostgreSQL будет выполнять ваш запрос, и даёт возможность оптимизировать его производительность.

При использовании команды <b>EXPLAIN ANALYZE</b>, кроме плана выполнения, будет произведено и фактическое выполнение запроса, собраны статистические данные и включено время выполнения каждой операции в плане.

Например, чтобы получить план выполнения запроса SELECT * FROM users, можно использовать следующую команду:

```sql
EXPLAIN SELECT * FROM users;
```

Это позволит увидеть, как PostgreSQL планирует выполнить этот запрос, т.е. какие индексы и операции будут использованы. В результате вы получите структурированную информацию, которая поможет вам оптимизировать запросы и улучшить производительность вашей базы данных.


### Триггеры

Триггеры в SQL - это специальные объекты базы данных, которые активизируются автоматически при определенных событиях или изменениях данных в таблице. Триггеры могут использоваться для автоматического выполнения определенных действий, проверки целостности данных или записи изменений в журналы.

```sql
CREATE TRIGGER after_insert_example
AFTER INSERT ON your_table
FOR EACH ROW
BEGIN
    -- Код действий, выполняемых после вставки в таблицу
END;
```

Примером практического использования триггеров может быть следующая ситуация: при вставке новых данных в таблицу "orders", триггер "after_insert_example" может автоматически обновить сумму заказов в таблице "customers".


### ALTER SYSTEM

SQL-интерфейс для редактирования конфигурационного файла postgresql.conf:
```sql
ALTER SYSTEM SET port TO 5433;
```

`ALTER SYSTEM RESET <параметр>` удаляет строку
`ALTER SYSTEM RESET ALL`    удаляет все строки


### Табличные пространства

Табличное пространство (tablespace) - это место, где хранятся фактические файлы данных, относящиеся к таблицам и индексам базы данных. Табличные пространства дают возможность управлять тем, где физически располагаются данные в базе данных.

Основные преимущества использования табличных пространств:

1. **Распределение данных**: Позволяет хранить данные на различных физических дисках или разделах дисков для более эффективного управления местом.
  
2. **Увеличение производительности**: Позволяет разместить данные на быстрых дисках или разделах, что может улучшить производительность базы данных.

3. **Управление местом хранения**: Позволяет размещать различные объекты базы данных (таблицы, индексы) в разных табличных пространствах.

В PostgreSQL можно создавать и использовать пользовательские табличные пространства для своих объектов базы данных. Например, чтобы создать табличное пространство с именем 'data_space' в каталоге '/mnt/data', можно выполнить следующий SQL запрос:

```sql
CREATE TABLESPACE data_space LOCATION '/mnt/data';
```

После создания табличного пространства, можно указывать его при создании таблиц или индексов с использованием параметра `TABLESPACE` в командах `CREATE TABLE` или `CREATE INDEX`.

Например, чтобы создать таблицу в пользовательском табличном пространстве 'data_space':
```sql
CREATE TABLE my_table 
(
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
) TABLESPACE data_space;
```

Таким образом, использование табличных пространств в PostgreSQL дает возможность гибко управлять распределением данных и ресурсами базы данных для оптимальной производительности и удобства администрирования.

Удалить табличное пространство если в нем есть некоторое содержимое невозможно. Для этого нужно либо удалить таблицы отдельно, либо перенести их. Чтобы перенести таблицы в табличное пространство по-умолчанию, нужно подключиться к базе данных и выполнить команду:
```sql
ALTER DATABASE db_test SET TABLESPACE pg_default;
```

Затем можно удалять пустое табличное пространство:
```sql
DROP TABLESPACE test_tablespace;
```


### WITH

Ключевое слово WITH используется для создания временных (или общих) таблиц, с которыми можно работать в запросе. При использовании WITH создается временная таблица (также известная как Common Table Expression - CTE), которая может использоваться в последующих частях запроса. Это позволяет делать запросы более структурированными, гибкими и легкими для понимания.

WITH состоит из нескольких частей:

1. Начало с ключевого слова WITH,
2. Имя временной таблицы,
3. Определение столбцов временной таблицы (если необходимо),
4. Оператор AS, который указывает начало определения временной таблицы,
5. Запрос, который извлекает данные для временной таблицы.

Пример использования WITH в SQL:

```sql
WITH sales AS (
    SELECT product_id, SUM(amount) AS total_sales
    FROM order_items
    GROUP BY product_id
)

SELECT products.product_name, sales.total_sales
FROM products
JOIN sales ON products.product_id = sales.product_id;
```

В этом примере создается временная таблица `sales`, которая содержит суммарные продажи для каждого продукта из таблицы `order_items`. Затем эта временная таблица объединяется с таблицей `products`, чтобы показать продукты и их общие продажи.

WITH в SQL полезен для упрощения запросов, улучшения читаемости кода и повышения производительности при выполнении сложных запросов.


### PREPARE

Оператор `PREPARE` используется для подготовки и кэширования запросов до их выполнения. Это позволяет уменьшить накладные расходы на обработку запроса и повторно использовать его в дальнейшем для улучшения производительности.

Процесс использования оператора `PREPARE`:
1. Сначала подготавливается запрос с помощью оператора `PREPARE`, указывается имя для подготовленного запроса и сам запрос.
2. Затем выполняется этот подготовленный запрос с помощью оператора `EXECUTE`.
3. Для очистки или удаления подготовленного запроса можно использовать оператор `DEALLOCATE`.

Пример использования оператора `PREPARE`:
```sql
PREPARE my_statement (INT) AS
SELECT * FROM products WHERE product_id = $1;

EXECUTE my_statement(10);
```

В результате этого кода будет выполнен запрос, который выберет все столбцы из таблицы `products` для записей, где `product_id` равен 10.

Оператор `PREPARE` полезен, когда у вас есть запросы, которые нужно многократно выполнить с разными значениями параметров, таким образом повышая производительность запросов.

В SQL запросе, `$1` означает параметр, который будет передан в запрос во время выполнения. Такой подход позволяет делать запросы более универсальными и безопасными, так как параметры могут быть динамически вставлены в запрос без опасности SQL-инъекций.

При использовании `PREPARE` можно создать параметризованный запрос, в котором вместо конкретного значения подставляется переменная:
```sql
SELECT * FROM products
WHERE product_id = $1 AND price > $2;
```

В данном случае "<b>$1</b>" и "<b>$2</b>" - это параметры, которые должны быть переданы при выполнении запроса. Если выполнить подготовку запроса с помощью `PREPARE`, то при его выполнении вместо "$1" и "$2" будут подставлены соответствующие значения. Например, чтобы выполнить запрос для product_id=100 и цены больше 50, нужно выполнить что-то вроде:
```sql
EXECUTE my_prepared_query(100, 50);
```

Таким образом, "$1", "$2" и т.д. обозначают параметры и предполагают использование подстановки значений при выполнении запроса.


### Составные типы

Составные типы в SQL позволяют создавать пользовательские типы данных, которые могут быть представлены как структурные типы, содержащие несколько атрибутов или полей. Такие типы могут быть используемы в качестве аргументов функций, переменных и полях таблиц.

Использование составных типов делает код более читаемым и понятным, позволяя логически группировать данные.

```sql
CREATE TYPE address AS (
    street VARCHAR(50),
    city VARCHAR(50),
    zip_code VARCHAR(10)
);

CREATE TABLE employees
(
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR(50),
    home_address address
);

INSERT INTO employees(name, home_address) 
VALUES('John Doe', ROW('123 Main St', 'Anytown', '12345'));
```

В этом примере `address` - это составной тип, содержащий три поля `street`, `city` и `zip_code`. Затем этот тип используется как атрибут структуры в таблице `employees`.


### Партицирование

Партиции являются способом разделения больших таблиц на более мелкие и управляемые части, что позволяет улучшить производительность запросов и обеспечить более эффективное управление данными. Партиции позволяют разбить таблицы на небольшие части, которые могут быть обработаны независимо друг от друга.

С помощью партиций в PostgreSQL можно разбивать данные по различным критериям, таким как диапазон значений, значения хэш-функции или списки значений. Например, можно создать партиции по диапазонам дат или по значениям некоторого поля таблицы.

```sql
CREATE TABLE sales 
(
    sale_id SERIAL PRIMARY KEY,
    sale_date DATE,
    sale_amount NUMERIC
);

CREATE TABLE sales_2019 PARTITION OF sales
FOR VALUES FROM ('2019-01-01') TO ('2020-01-01');

CREATE TABLE sales_2020 PARTITION OF sales
FOR VALUES FROM ('2020-01-01') TO ('2021-01-01');
```